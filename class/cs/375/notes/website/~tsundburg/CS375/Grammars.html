

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Grammars &mdash; Compilers and Interpreters 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Compilers and Interpreters 1.0 documentation" href="index.html"/>
        <link rel="next" title="Operators" href="Operators.html"/>
        <link rel="prev" title="Regular Expressions" href="RegularExpressions.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="index.html" class="icon icon-home"> Compilers and Interpreters
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="PartsOfTheCompiler.html">Parts Of The Compiler</a><ul>
<li class="toctree-l2"><a class="reference internal" href="PartsOfTheCompiler.html#lexical-analysis-tokenizer">Lexical Analysis (Tokenizer)</a></li>
<li class="toctree-l2"><a class="reference internal" href="PartsOfTheCompiler.html#syntax-analysis-parser">Syntax Analysis (Parser)</a></li>
<li class="toctree-l2"><a class="reference internal" href="PartsOfTheCompiler.html#abstract-syntax-tree-ast">Abstract Syntax Tree (AST)</a></li>
<li class="toctree-l2"><a class="reference internal" href="PartsOfTheCompiler.html#semantic-analysis">Semantic Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="PartsOfTheCompiler.html#interpreter">Interpreter</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="DeterministicFiniteAutomata.html">Deterministic Finite Automata (DFA)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="DeterministicFiniteAutomata.html#traversal-algorithm">Traversal Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="DeterministicFiniteAutomata.html#backtracking-and-lookahead">Backtracking and Lookahead</a><ul>
<li class="toctree-l3"><a class="reference internal" href="DeterministicFiniteAutomata.html#la-1-examples">LA(1) Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="DeterministicFiniteAutomata.html#la-2-examples">LA(2) Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="DeterministicFiniteAutomata.html#la-examples">LA(*) Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="DeterministicFiniteAutomata.html#lookahead-implementation">Lookahead Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="DeterministicFiniteAutomata.html#parsing-integers">Parsing Integers</a></li>
<li class="toctree-l2"><a class="reference internal" href="DeterministicFiniteAutomata.html#parsing-floats">Parsing Floats</a></li>
<li class="toctree-l2"><a class="reference internal" href="DeterministicFiniteAutomata.html#parsing-keywords">Parsing Keywords</a></li>
<li class="toctree-l2"><a class="reference internal" href="DeterministicFiniteAutomata.html#parsing-identifiers">Parsing Identifiers</a></li>
<li class="toctree-l2"><a class="reference internal" href="DeterministicFiniteAutomata.html#parsing-operators">Parsing Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="DeterministicFiniteAutomata.html#state-structure">State Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="DeterministicFiniteAutomata.html#hard-coded-dfa">Hard-coded DFA</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="RegularExpressions.html">Regular Expressions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="RegularExpressions.html#core-operators">Core Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#union">Union <strong>|</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#concatenation">Concatenation</a></li>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#kleene-closure">Kleene Closure <strong>*</strong></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="RegularExpressions.html#extended-operators">Extended Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#character-sets">Character Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#positive-closure">Positive Closure <strong>+</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#optional">Optional <strong>?</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#interval-min-max-min-n">Interval <strong>{min,max}</strong> <strong>{min,}</strong> <strong>{n}</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#any-character">Any Character <strong>.</strong></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="RegularExpressions.html#other-operators">Other Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#escape-character">Escape Character <strong>\</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#anchors-and">Anchors <strong>^</strong> and <strong>$</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#word-boundaries-b">Word Boundaries <strong>\b</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#capture-group">Capture Group <strong>()</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#passive-group">Passive Group <strong>(?:)</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="RegularExpressions.html#replacement-back-reference">Replacement Back Reference <strong>$</strong></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="RegularExpressions.html#cheat-sheets">Cheat Sheets</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="Grammars.html#">Grammars</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Grammars.html#similarity-to-regular-expressions">Similarity To Regular Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="Grammars.html#derivations-and-parse-trees">Derivations and Parse Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="Grammars.html#ambiguity">Ambiguity</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Grammars.html#classic-examples-of-ambiguity">Classic Examples of Ambiguity</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Grammars.html#elimination-of-ambiguity">Elimination of Ambiguity</a></li>
<li class="toctree-l2"><a class="reference internal" href="Grammars.html#left-recursion">Left Recursion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Operators.html">Operators</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Operators.html#associativity">Associativity</a></li>
<li class="toctree-l2"><a class="reference internal" href="Operators.html#precedence">Precedence</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="RecursiveDescent.html">Recursive Descent Parsing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="RecursiveDescent.html#predictive-parser">Predictive Parser</a></li>
<li class="toctree-l2"><a class="reference internal" href="RecursiveDescent.html#guidelines">Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="RecursiveDescent.html#alternations">Alternations</a></li>
<li class="toctree-l2"><a class="reference internal" href="RecursiveDescent.html#alternation-and-concatenation">Alternation and Concatenation</a></li>
<li class="toctree-l2"><a class="reference internal" href="RecursiveDescent.html#recursion">Recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="RecursiveDescent.html#alternation-empty-rule">Alternation Empty Rule</a><ul>
<li class="toctree-l3"><a class="reference internal" href="RecursiveDescent.html#optional-token">Optional Token</a></li>
<li class="toctree-l3"><a class="reference internal" href="RecursiveDescent.html#optional-rule">Optional Rule</a></li>
<li class="toctree-l3"><a class="reference internal" href="RecursiveDescent.html#optional-concatenation">Optional Concatenation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="RecursiveDescent.html#kleene-and-positive-closures">Kleene and Positive Closures</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="AbstractSyntaxTree.html">Abstract Syntax Tree</a><ul>
<li class="toctree-l2"><a class="reference internal" href="AbstractSyntaxTree.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="AbstractSyntaxTree.html#heterogeneous-nodes">Heterogeneous Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="AbstractSyntaxTree.html#homogeneous-nodes">Homogeneous Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="AbstractSyntaxTree.html#heterogeneous-double-dispatch">Heterogeneous Double Dispatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="AbstractSyntaxTree.html#node-allocation-and-storage">Node Allocation And Storage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="StaticVsDynamic.html">Static vs Dynamic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="StaticVsDynamic.html#static-typing">Static Typing</a></li>
<li class="toctree-l2"><a class="reference internal" href="StaticVsDynamic.html#dynamic-typing">Dynamic Typing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="StaticVsDynamic.html#scalar-variables">Scalar Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="StaticVsDynamic.html#table-or-object">Table or Object</a></li>
<li class="toctree-l3"><a class="reference internal" href="StaticVsDynamic.html#inheritance-and-polymorphism">Inheritance and Polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="StaticVsDynamic.html#functions">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="StaticVsDynamic.html#operator-overloading">Operator Overloading</a></li>
<li class="toctree-l3"><a class="reference internal" href="StaticVsDynamic.html#reflection">Reflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="StaticVsDynamic.html#templates">Templates</a></li>
<li class="toctree-l3"><a class="reference internal" href="StaticVsDynamic.html#overloads-function-templates">Overloads &amp; Function Templates</a></li>
<li class="toctree-l3"><a class="reference internal" href="StaticVsDynamic.html#monkey-patching">Monkey Patching</a></li>
<li class="toctree-l3"><a class="reference internal" href="StaticVsDynamic.html#implementation">Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="SemanticAnalysis.html">Semantic Analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="SemanticAnalysis.html#scope-resolution">Scope Resolution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="SemanticAnalysis.html#name-hiding">Name Hiding</a></li>
<li class="toctree-l3"><a class="reference internal" href="SemanticAnalysis.html#types-members-variables">Types, Members, Variables</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="SemanticAnalysis.html#symbol-table-aka-meta">Symbol Table aka Meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="SemanticAnalysis.html#computing-types">Computing Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="SemanticAnalysis.html#type-inference">Type Inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="SemanticAnalysis.html#l-r-values">L/R Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="SemanticAnalysis.html#syntactic-sugar">Syntactic Sugar</a></li>
<li class="toctree-l2"><a class="reference internal" href="SemanticAnalysis.html#control-flow">Control Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="SemanticAnalysis.html#member-resolution">Member Resolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="SemanticAnalysis.html#duplicate-members-overloads">Duplicate Members &amp; Overloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="SemanticAnalysis.html#overload-resolution">Overload Resolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="SemanticAnalysis.html#module-based-compilation">Module Based Compilation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ErrorRecovery.html">Error Recovery</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ErrorRecovery.html#tokenization">Tokenization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ErrorRecovery.html#panic-mode">Panic Mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="ErrorRecovery.html#error-edges">Error Edges</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ErrorRecovery.html#parsing">Parsing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ErrorRecovery.html#id1">Panic Mode</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ErrorRecovery.html#semantic-analysis">Semantic Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ErrorRecovery.html#classnode">ClassNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="ErrorRecovery.html#binaryoperatornode">BinaryOperatorNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="ErrorRecovery.html#memberaccessnode">MemberAccessNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="ErrorRecovery.html#poison">Poison</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ErrorRecovery.html#code-generation">Code Generation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="AstInterpreter.html">AST Interpreter</a><ul>
<li class="toctree-l2"><a class="reference internal" href="AstInterpreter.html#advantages">Advantages</a></li>
<li class="toctree-l2"><a class="reference internal" href="AstInterpreter.html#disadvantages">Disadvantages</a></li>
<li class="toctree-l2"><a class="reference internal" href="AstInterpreter.html#execution">Execution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="AstInterpreter.html#expressions">Expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="AstInterpreter.html#literals">Literals</a></li>
<li class="toctree-l4"><a class="reference internal" href="AstInterpreter.html#binary-operators">Binary Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="AstInterpreter.html#unary-operators">Unary Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="AstInterpreter.html#type-casting">Type Casting</a></li>
<li class="toctree-l4"><a class="reference internal" href="AstInterpreter.html#member-access">Member Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="AstInterpreter.html#if-statements">If Statements</a></li>
<li class="toctree-l4"><a class="reference internal" href="AstInterpreter.html#while-do-while-for-etc">While, Do-While, For, Etc</a></li>
<li class="toctree-l4"><a class="reference internal" href="AstInterpreter.html#return">Return</a></li>
<li class="toctree-l4"><a class="reference internal" href="AstInterpreter.html#break-and-continue">Break and Continue</a></li>
<li class="toctree-l4"><a class="reference internal" href="AstInterpreter.html#exceptions">Exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="AstInterpreter.html#function-calls">Function Calls</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="AstInterpreter.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ModernLanguages.html">Modern Languages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ModernLanguages.html#return-type-inference">Return Type Inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="ModernLanguages.html#decltype">Decltype</a></li>
<li class="toctree-l2"><a class="reference internal" href="ModernLanguages.html#delegates">Delegates</a></li>
<li class="toctree-l2"><a class="reference internal" href="ModernLanguages.html#closures-anonymous-functions">Closures &amp; Anonymous Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ModernLanguages.html#properties">Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="ModernLanguages.html#extension-functions-properties">Extension Functions &amp; Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="ModernLanguages.html#pure-functions">Pure Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ModernLanguages.html#mixins">Mixins</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="IntermediateRepresentation.html">Intermediate Representation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="IntermediateRepresentation.html#front-back-end">Front/Back End</a></li>
<li class="toctree-l2"><a class="reference internal" href="IntermediateRepresentation.html#three-address-code">Three Address Code</a><ul>
<li class="toctree-l3"><a class="reference internal" href="IntermediateRepresentation.html#code-generation-example">Code Generation Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="IntermediateRepresentation.html#static-single-assignment">Static Single Assignment</a></li>
<li class="toctree-l2"><a class="reference internal" href="IntermediateRepresentation.html#basic-blocks">Basic Blocks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="VirtualMachine.html">Virtual Machine</a><ul>
<li class="toctree-l2"><a class="reference internal" href="VirtualMachine.html#instructions">Instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="VirtualMachine.html#reduced-instruction-set-computing">Reduced Instruction Set Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="VirtualMachine.html#complex-instruction-set-computing">Complex Instruction Set Computing</a></li>
<li class="toctree-l2"><a class="reference internal" href="VirtualMachine.html#stack-machine">Stack Machine</a><ul>
<li class="toctree-l3"><a class="reference internal" href="VirtualMachine.html#advantages">Advantages</a></li>
<li class="toctree-l3"><a class="reference internal" href="VirtualMachine.html#disadvantages">Disadvantages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="VirtualMachine.html#random-access-machine">Random Access Machine</a><ul>
<li class="toctree-l3"><a class="reference internal" href="VirtualMachine.html#id1">Advantages</a></li>
<li class="toctree-l3"><a class="reference internal" href="VirtualMachine.html#id2">Disadvantages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="VirtualMachine.html#register-machine">Register Machine</a><ul>
<li class="toctree-l3"><a class="reference internal" href="VirtualMachine.html#id3">Advantages</a></li>
<li class="toctree-l3"><a class="reference internal" href="VirtualMachine.html#id4">Disadvantages</a></li>
<li class="toctree-l3"><a class="reference internal" href="VirtualMachine.html#register-allocation">Register Allocation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="VirtualMachine.html#infinite-registers">Infinite Registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="VirtualMachine.html#register-reuse">Register Reuse</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="GarbageCollection.html">Garbage Collection</a><ul>
<li class="toctree-l2"><a class="reference internal" href="GarbageCollection.html#why">Why?</a></li>
<li class="toctree-l2"><a class="reference internal" href="GarbageCollection.html#safety">Safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="GarbageCollection.html#misconceptions">Misconceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="GarbageCollection.html#garbage-collector-roots">Garbage Collector Roots</a></li>
<li class="toctree-l2"><a class="reference internal" href="GarbageCollection.html#common-issues">Common Issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="GarbageCollection.html#mark-and-sweep">Mark and Sweep</a><ul>
<li class="toctree-l3"><a class="reference internal" href="GarbageCollection.html#mark-phase">Mark Phase</a></li>
<li class="toctree-l3"><a class="reference internal" href="GarbageCollection.html#sweep-phase">Sweep Phase</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="GarbageCollection.html#defragmentation">Defragmentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="GarbageCollection.html#reference-counting">Reference Counting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="GarbageCollection.html#advantages">Advantages</a></li>
<li class="toctree-l3"><a class="reference internal" href="GarbageCollection.html#disadvantages">Disadvantages</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ApplicationBinaryInterface.html">Application Binary Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ApplicationBinaryInterface.html#name-mangling">Name Mangling</a></li>
<li class="toctree-l2"><a class="reference internal" href="ApplicationBinaryInterface.html#standardization">Standardization</a></li>
<li class="toctree-l2"><a class="reference internal" href="ApplicationBinaryInterface.html#calling-convention">Calling Convention</a></li>
<li class="toctree-l2"><a class="reference internal" href="ApplicationBinaryInterface.html#libraries">Libraries</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ApplicationBinaryInterface.html#dynamic-linked-libraries">Dynamic Linked Libraries</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ApplicationBinaryInterface.html#structures">Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="ApplicationBinaryInterface.html#virtual-tables">Virtual Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="ApplicationBinaryInterface.html#runtime-type-identification">Runtime Type Identification</a></li>
<li class="toctree-l2"><a class="reference internal" href="ApplicationBinaryInterface.html#exceptions">Exceptions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="CompilerAsAService.html">Compiler As A Service (IDE)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#minimal-rebuild">Minimal Rebuild</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#member-auto-complete">Member Auto Complete</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#call-tips-overloads">Call Tips / Overloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#local-expression-completion">Local / Expression Completion</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#cursor-hovering">Cursor Hovering</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#go-to-definition">Go To Definition</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#symbol-querying">Symbol Querying</a><ul>
<li class="toctree-l3"><a class="reference internal" href="CompilerAsAService.html#typenode">TypeNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="CompilerAsAService.html#variablenode">VariableNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="CompilerAsAService.html#namereferencenode">NameReferenceNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="CompilerAsAService.html#memberaccessnode">MemberAccessNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="CompilerAsAService.html#callnode">CallNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="CompilerAsAService.html#classnode-functionnode">ClassNode/FunctionNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="CompilerAsAService.html#expressionnode">ExpressionNode</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#comments">Comments</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#refactor-rename">Refactor Rename</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#debuggers">Debuggers</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#formatting">Formatting</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#statement-evaluation">Statement Evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#read-eval-print-loop">Read Eval Print Loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="CompilerAsAService.html#other-features">Other Features</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Assignment1.html">Assignment 1</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Assignment1.html#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Assignment2.html">Assignment 2</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Assignment2.html#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Assignment3.html">Assignment 3</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Assignment3.html#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Assignment4.html">Assignment 4</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Assignment4.html#implementation">Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Assignment4.html#pass-4">Pass 4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#literalnode">LiteralNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#namereferencenode">NameReferenceNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#indexnode">IndexNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#memberaccessnode">MemberAccessNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#binaryoperatornode">BinaryOperatorNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#unaryoperatornode">UnaryOperatorNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#callnode">CallNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#castnode">CastNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#ifnode-fornode-whilenode">IfNode/ForNode/WhileNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#gotonode">GotoNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#returnnode">ReturnNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment4.html#parameternode-variablenode">ParameterNode/VariableNode</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Assignment5.html">Assignment 5</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Assignment5.html#implementation">Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Assignment5.html#pass-1-pre-pass">Pass 1 (Pre-Pass)</a></li>
<li class="toctree-l2"><a class="reference internal" href="Assignment5.html#interpreterfunctioncall">InterpreterFunctionCall</a></li>
<li class="toctree-l2"><a class="reference internal" href="Assignment5.html#pass-2-interpretation">Pass 2 (Interpretation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Assignment5.html#variablenode">VariableNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment5.html#returnnode">ReturnNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment5.html#ifnode">IfNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment5.html#whilenode">WhileNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment5.html#castnode">CastNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment5.html#literalnode">LiteralNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment5.html#namereferencenode">NameReferenceNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment5.html#binaryoperatornode">BinaryOperatorNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Assignment5.html#callnode">CallNode</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Assignment5.html#addsinfunction">AddSinFunction</a></li>
<li class="toctree-l2"><a class="reference internal" href="Assignment5.html#unhandled-nodes">Unhandled Nodes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="AssignmentSubmission.html">Assignment Submission</a></li>
<li class="toctree-l1"><a class="reference external" href="../CS375Assignments.1.html#://">Assignment Downloads</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Compilers and Interpreters</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Grammars</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/Grammars.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="grammars">
<h1>Grammars<a class="headerlink" href="Grammars.html#grammars" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>Programming languages are generally hierarchical</li>
<li>A scoped statement can contain zero or more nested scoped statements</li>
<li>We need a way to describe the <em>recursive</em> rules of parsing our language</li>
<li>A <em>grammar</em> describes all the parsing rules for our language (can also be used for a lexer)</li>
<li>There are many different existing formats for describing grammars (BNF, EBNF, etc)</li>
<li>The grammar of an <em>if</em> statement might look something like the following</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Statement</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">If</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">OpenParentheses</span><span class="o">&gt;</span> <span class="n">Expression</span> <span class="o">&lt;</span><span class="n">CloseParentheses</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">OpenCurley</span><span class="o">&gt;</span> <span class="n">Statement</span> <span class="o">&lt;</span><span class="n">CloseCurley</span><span class="o">&gt;</span>
          <span class="o">|</span> <span class="o">&lt;</span><span class="n">Var</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">Identifier</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">Assignment</span><span class="o">&gt;</span> <span class="n">Expression</span> <span class="o">&lt;</span><span class="n">Semicolon</span><span class="o">&gt;</span>
</pre></div>
</div>
<ul class="simple">
<li>We left off the definition of Expression for simplicity</li>
<li>Any token wrapped in &lt;&gt; comes from our Tokenizer (the enum value)</li>
<li>In any grammar, the tokens are formally referred to as a <em>terminal</em></li>
<li><code class="docutils literal"><span class="pre">Statement</span></code>, <code class="docutils literal"><span class="pre">Expression</span></code> are <em>non-terminals</em></li>
<li>The equals sign after <code class="docutils literal"><span class="pre">Statement</span></code> is referred to as a <em>production</em> or rule</li>
<li>The <em>or</em> symbol <code class="docutils literal"><span class="pre">|</span></code> can be used to define multiple rules for a <em>production</em></li>
<li>Whitespace and newlines are irrelevant in our grammar definition</li>
</ul>
<p>You might also see that same grammar defined with EBNF:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Statement</span> <span class="o">=</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;(&quot;</span> <span class="n">Expression</span> <span class="s2">&quot;)&quot;</span> <span class="s2">&quot;{&quot;</span> <span class="n">Statement</span> <span class="s2">&quot;}&quot;</span>
          <span class="o">|</span> <span class="s2">&quot;var&quot;</span> <span class="n">Identifier</span> <span class="s2">&quot;=&quot;</span> <span class="n">Expression</span> <span class="s2">&quot;;&quot;</span>
</pre></div>
</div>
<ul class="simple">
<li>EBNF assumes you are defining everything about your language, including token semantics</li>
<li>There is no formal way to specify that a token came from a previous phase, such as a tokenizer</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MatchingParenthesis</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">OpenParentheses</span><span class="o">&gt;</span> <span class="n">MatchingParenthesis</span> <span class="o">&lt;</span><span class="n">CloseParentheses</span><span class="o">&gt;</span>
                    <span class="o">|</span> <span class="o">&lt;</span><span class="n">OpenParentheses</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">CloseParentheses</span><span class="o">&gt;</span>
</pre></div>
</div>
<ul class="simple">
<li>The recursive nature of grammars allows us to do more than a DFA</li>
<li>Try and create a DFA that allows for an infinite number of matching <code class="docutils literal"><span class="pre">(</span></code> and <code class="docutils literal"><span class="pre">)</span></code></li>
<li>E.g. <code class="docutils literal"><span class="pre">()</span></code>  or <code class="docutils literal"><span class="pre">(())</span></code> or <code class="docutils literal"><span class="pre">(((())))</span></code></li>
<li>With a grammar, this is trivial</li>
<li>As with all things recursion, we need a base case, hence the <code class="docutils literal"><span class="pre">&lt;OpenParentheses&gt;</span> <span class="pre">&lt;CloseParentheses&gt;</span></code></li>
</ul>
<div class="section" id="similarity-to-regular-expressions">
<h2>Similarity To Regular Expressions<a class="headerlink" href="Grammars.html#similarity-to-regular-expressions" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>The only major difference between grammars and regular expressions is recursion</li>
<li>We can apply the same operators and algebra to a grammar</li>
<li><code class="docutils literal"><span class="pre">&lt;Static&gt;</span> <span class="pre">&lt;Var&gt;</span> <span class="pre">|</span> <span class="pre">&lt;Static&gt;</span> <span class="pre">&lt;Function&gt;</span></code> can be factored into <code class="docutils literal"><span class="pre">&lt;Static&gt;</span> <span class="pre">(&lt;Var&gt;</span> <span class="pre">|</span> <span class="pre">&lt;Function&gt;)</span></code><ul>
<li>Using the <em>distributive</em> property (more importantly the reverse which is left factoring)</li>
</ul>
</li>
<li>We can also use all the other operators, such as *, +, ?, grouping (), epsilon ϵ, etc</li>
<li>This does make it convenient to also write the token grammar along with the language grammar<ul>
<li>Recommended that you separate the token grammar from parser grammar</li>
</ul>
</li>
<li>Concatenation (two &lt;Terminals&gt; next to each other) is still the highest precedence</li>
</ul>
<p>We can rewrite the above matching parentheses rule in a few different ways...</p>
<p>By factoring the grammar. This is essential for writing a predictive parser in the next section because it removes any need for backtracking:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MatchingParenthesis</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">OpenParentheses</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">CloseParentheses</span><span class="o">&gt;</span> <span class="o">|</span> <span class="n">MatchingParenthesis</span> <span class="o">&lt;</span><span class="n">CloseParentheses</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>Using the epsilon rule:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MatchingParenthesis</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">OpenParentheses</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">MatchingParenthesis</span> <span class="o">|</span> <span class="n">e</span><span class="p">)</span> <span class="o">&lt;</span><span class="n">CloseParentheses</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Or using the ? operator (the most convenient to visualize, also easy to implement):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>MatchingParenthesis = &lt;OpenParentheses&gt; MatchingParenthesis? &lt;CloseParentheses&gt;
</pre></div>
</div>
<ul class="simple">
<li>Multiple grammars represent the same language</li>
<li>A mathematical set of all possible ordered token strings</li>
</ul>
</div>
<div class="section" id="derivations-and-parse-trees">
<h2>Derivations and Parse Trees<a class="headerlink" href="Grammars.html#derivations-and-parse-trees" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>A parse tree visually shows how we take input text and apply the productions to it</li>
<li>When parsing any grammar we must have a starting <em>non-terminal</em> (the first one)</li>
<li>Lets take a look at a very simple grammar</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">List</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">Identifier</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">Comma</span><span class="o">&gt;</span> <span class="n">List</span>
     <span class="o">|</span> <span class="o">&lt;</span><span class="n">Identifier</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Using the above grammar with the starting <em>non-terminal</em> of List, we will parse the following text into a parse tree:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="n">baz</span>
</pre></div>
</div>
<ul class="simple">
<li>When we&#8217;re parsing we have to look at which rules can possibly match, and if one fails we try the next rule</li>
<li>Starting with the first rule we see that <code class="docutils literal"><span class="pre">foo</span></code> is an identifier, and we find the following <code class="docutils literal"><span class="pre">,</span></code></li>
<li>Because that rule recursively uses the List <em>non-terminal</em> then we must start again at <code class="docutils literal"><span class="pre">bar</span></code></li>
<li>The tokens <code class="docutils literal"><span class="pre">bar</span></code> and <code class="docutils literal"><span class="pre">,</span></code> match the first rule again, so we again recursively enter List</li>
<li>Finally we reach <code class="docutils literal"><span class="pre">baz</span></code>, but no <code class="docutils literal"><span class="pre">,</span></code> follows, so we must try another rule (<em>production</em>)</li>
<li>The token <code class="docutils literal"><span class="pre">baz</span></code> fits the second rule, and as a base case we ended the recursion</li>
<li>Why didn&#8217;t we just choose the second rule when parsing <code class="docutils literal"><span class="pre">foo</span></code>?</li>
<li>Because we are greedy! Our parsing should want to parse as much as possible (think about reading a book)</li>
<li>Technically the order of the rules should not matter, so long as the grammar is not <em>ambiguous</em></li>
</ul>
<p>We can represent the above logic in a more concisely with the following <em>derivation</em>. A <em>derivation</em> starts with a rule and expands each <em>non-terminal</em> with another rule. We backup and try another rule if the rule we are currently trying fails. The last line of a <em>derivation</em> always ends in <em>terminals</em> or tokens. We use <em>EBNF</em> style when performing derivations because its more concise.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">List</span> <span class="o">=&gt;</span> <span class="n">Identifier</span> <span class="s2">&quot;,&quot;</span> <span class="n">List</span>             <span class="o">//</span> <span class="n">Starting</span> <span class="n">rule</span>
     <span class="o">=&gt;</span> <span class="s2">&quot;foo&quot;</span> <span class="s2">&quot;,&quot;</span> <span class="n">List</span>                  <span class="o">//</span> <span class="n">Expand</span> <span class="n">Identifier</span> <span class="ow">and</span> <span class="n">Comma</span>
     <span class="o">=&gt;</span> <span class="s2">&quot;foo&quot;</span> <span class="s2">&quot;,&quot;</span> <span class="n">Identifier</span> <span class="s2">&quot;,&quot;</span> <span class="n">List</span>   <span class="o">//</span> <span class="n">Expand</span> <span class="n">List</span> <span class="p">(</span><span class="n">first</span> <span class="n">rule</span><span class="p">)</span>
     <span class="o">=&gt;</span> <span class="s2">&quot;foo&quot;</span> <span class="s2">&quot;,&quot;</span> <span class="s2">&quot;bar&quot;</span> <span class="s2">&quot;,&quot;</span> <span class="n">List</span>        <span class="o">//</span> <span class="n">Expand</span> <span class="n">Identifier</span> <span class="ow">and</span> <span class="n">Comma</span>
     <span class="o">=&gt;</span> <span class="s2">&quot;foo&quot;</span> <span class="s2">&quot;,&quot;</span> <span class="s2">&quot;bar&quot;</span> <span class="s2">&quot;,&quot;</span> <span class="n">Identifier</span>  <span class="o">//</span> <span class="n">Expand</span> <span class="n">List</span> <span class="p">(</span><span class="n">first</span> <span class="n">rule</span> <span class="n">fails</span><span class="p">,</span> <span class="n">use</span> <span class="n">second</span> <span class="n">rule</span><span class="p">)</span>
     <span class="o">=&gt;</span> <span class="s2">&quot;foo&quot;</span> <span class="s2">&quot;,&quot;</span> <span class="s2">&quot;bar&quot;</span> <span class="s2">&quot;,&quot;</span> <span class="s2">&quot;baz&quot;</span>       <span class="o">//</span> <span class="n">Expand</span>
</pre></div>
</div>
<p>The parse tree for the above List grammar and input text would look like:</p>
<object data="_images/graphviz-cb10d4ba82e736791cec937234bda737a69726b1.svg" type="image/svg+xml">
            <p class="warning">digraph
{
  node [fontsize=10, fontname=Verdana, shape=rectangle, margin=0.1, width=0.35, height=0.35, label=&quot;&quot;];
  edge [fontsize=10, fontname=Verdana];

  List0 -&gt; Identifier0;
  Identifier0 -&gt; foo0;
  List0 -&gt; comma0;
  List0 -&gt; List1;

  List1 -&gt; Identifier1;
  Identifier1 -&gt; bar0;
  List1 -&gt; comma1;
  List1 -&gt; List2;

  List2 -&gt; Identifier2;
  Identifier2 -&gt; baz0;

  List0 [label=&quot;List&quot;];
  Identifier0 [label=&quot;Identifier&quot;];
  foo0 [label=&quot;foo&quot;];
  comma0 [label=&quot;,&quot;];
  List1 [label=&quot;List&quot;];
  Identifier1 [label=&quot;Identifier&quot;];
  bar0 [label=&quot;bar&quot;];
  comma1 [label=&quot;,&quot;];
  List2 [label=&quot;List&quot;];
  Identifier2 [label=&quot;Identifier&quot;];
  baz0 [label=&quot;baz&quot;];
}</p></object>
<ul class="simple">
<li>Every parent node is a <em>non-terminal</em> such as List and Identifier</li>
<li>Every leaf node is a <em>terminal</em> or token, such as: <code class="docutils literal"><span class="pre">foo</span></code>  <code class="docutils literal"><span class="pre">bar</span></code>  <code class="docutils literal"><span class="pre">,</span></code></li>
<li>The first <em>non-terminal</em> that we start with is the root of the tree</li>
<li>Every time we read a token / <em>terminal</em> then we draw a leaf node with a connecting edge from the parent <em>non-terminal</em></li>
<li>Every time we enter a <em>non-terminal</em> then we draw a node with a connecting edge from the parent <em>non-terminal</em></li>
<li>If we find out that the <em>production</em> failed to parse, we need to backup (and erase the parts of the tree we just created)</li>
</ul>
<p>To avoid having to think about which production we need to choose, or being greedy, we can refactor this grammar again using the <em>distributive</em> property:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>List = &lt;Identifier&gt; (&lt;Comma&gt; List)?
</pre></div>
</div>
<p>Lets try another more in depth example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Statement</span>  <span class="o">=</span> <span class="o">&lt;</span><span class="n">If</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">OpenParentheses</span><span class="o">&gt;</span> <span class="n">Expression</span> <span class="o">&lt;</span><span class="n">CloseParentheses</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">OpenCurley</span><span class="o">&gt;</span> <span class="n">Statement</span> <span class="o">&lt;</span><span class="n">CloseCurley</span><span class="o">&gt;</span>
           <span class="o">|</span> <span class="o">&lt;</span><span class="n">Var</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">Identifier</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">Assignment</span><span class="o">&gt;</span> <span class="n">Expression</span> <span class="o">&lt;</span><span class="n">Semicolon</span><span class="o">&gt;</span>
<span class="n">Expression</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kc">True</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="kc">False</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Parse the following text with the above grammar, and derive a parse tree from it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">true</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">false</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">var</span> <span class="n">zombie</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>We start with the <code class="docutils literal"><span class="pre">Statement</span></code> <em>non-terminal</em></li>
<li>We start matching the <code class="docutils literal"><span class="pre">if</span></code> rule token by token</li>
<li>The <code class="docutils literal"><span class="pre">if</span></code> rule refers to the <code class="docutils literal"><span class="pre">Expression</span></code> <em>non-terminal</em>, so we walk down that</li>
<li>We find <code class="docutils literal"><span class="pre">true</span></code>, which completes the <code class="docutils literal"><span class="pre">Expression</span></code> <em>non-terminal</em></li>
<li>Continue parsing until we reach the <code class="docutils literal"><span class="pre">var</span></code> base case</li>
</ul>
<p>The derivation would be (using EBNF style to shorten it):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Statement</span> <span class="o">=&gt;</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;(&quot;</span> <span class="n">Expression</span> <span class="s2">&quot;)&quot;</span> <span class="s2">&quot;{&quot;</span> <span class="n">Statement</span> <span class="s2">&quot;}&quot;</span>
          <span class="o">=&gt;</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;(&quot;</span> <span class="s2">&quot;true&quot;</span> <span class="s2">&quot;)&quot;</span> <span class="s2">&quot;{&quot;</span> <span class="n">Statement</span> <span class="p">}</span>
          <span class="o">=&gt;</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;(&quot;</span> <span class="s2">&quot;true&quot;</span> <span class="s2">&quot;)&quot;</span> <span class="s2">&quot;{&quot;</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;(&quot;</span> <span class="n">Expression</span> <span class="s2">&quot;)&quot;</span> <span class="s2">&quot;{&quot;</span> <span class="n">Statement</span> <span class="s2">&quot;}&quot;</span> <span class="s2">&quot;}&quot;</span>
          <span class="o">=&gt;</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;(&quot;</span> <span class="s2">&quot;true&quot;</span> <span class="s2">&quot;)&quot;</span> <span class="s2">&quot;{&quot;</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;( &quot;</span><span class="n">false</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="s2">&quot; &quot;</span><span class="p">{</span><span class="s2">&quot; Statement &quot;</span><span class="p">}</span><span class="s2">&quot; &quot;</span><span class="p">}</span><span class="s2">&quot;</span>
          <span class="o">=&gt;</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;(&quot;</span> <span class="s2">&quot;true&quot;</span> <span class="s2">&quot;)&quot;</span> <span class="s2">&quot;{&quot;</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;( &quot;</span><span class="n">false</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="s2">&quot; &quot;</span><span class="p">{</span><span class="s2">&quot; &quot;</span><span class="n">var</span><span class="s2">&quot; &quot;</span><span class="n">zombie</span><span class="s2">&quot; &quot;</span><span class="o">=</span><span class="s2">&quot; Expression &quot;</span><span class="p">;</span><span class="s2">&quot; &quot;</span><span class="p">}</span><span class="s2">&quot; &quot;</span><span class="p">}</span><span class="s2">&quot;</span>
          <span class="o">=&gt;</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;(&quot;</span> <span class="s2">&quot;true&quot;</span> <span class="s2">&quot;)&quot;</span> <span class="s2">&quot;{&quot;</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;( &quot;</span><span class="n">false</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="s2">&quot; &quot;</span><span class="p">{</span><span class="s2">&quot; &quot;</span><span class="n">var</span><span class="s2">&quot; &quot;</span><span class="n">zombie</span><span class="s2">&quot; &quot;</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="n">true</span><span class="s2">&quot; &quot;</span><span class="p">;</span><span class="s2">&quot; &quot;</span><span class="p">}</span><span class="s2">&quot; &quot;</span><span class="p">}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>The parse tree for this input text and this grammar will be:</p>
<object data="_images/graphviz-7a8b9c1ee51646250d85ccadb92956c8bbcada54.svg" type="image/svg+xml">
            <p class="warning">digraph
{
  node [fontsize=10, fontname=Verdana, shape=rectangle, margin=0.1, width=0.35, height=0.35, label=&quot;&quot;];
  edge [fontsize=10, fontname=Verdana];

  Statement0 -&gt; if0;
  Statement0 -&gt; openParen0;
  Statement0 -&gt; Expression0;
  Expression0 -&gt; true0;
  Statement0 -&gt; closeParen0;
  Statement0 -&gt; openCurley0;
  Statement0 -&gt; Statement1;

  Statement1 -&gt; if1;
  Statement1 -&gt; openParen1;
  Statement1 -&gt; Expression1;
  Expression1 -&gt; false1;
  Statement1 -&gt; closeParen1;
  Statement1 -&gt; openCurley1;
  Statement1 -&gt; Statement2;

  Statement2 -&gt; var2;
  Statement2 -&gt; zombie2;
  Statement2 -&gt; assign2;
  Statement2 -&gt; Expression2;
  Expression2 -&gt; true2;
  Statement2 -&gt; endStatement2;

  Statement1 -&gt; closeCurley1;
  Statement0 -&gt; closeCurley0;

  Statement0 [label=&quot;Statement&quot;];
  if0 [label=&quot;if&quot;];
  openParen0 [label=&quot;(&quot;];
  Expression0 [label=&quot;Expression&quot;];
  true0 [label=&quot;true&quot;];
  closeParen0 [label=&quot;)&quot;];
  openCurley0 [label=&quot;{&quot;];
  Statement1 [label=&quot;Statement&quot;];
  if1 [label=&quot;if&quot;];
  openParen1 [label=&quot;(&quot;];
  Expression1 [label=&quot;Expression&quot;];
  false1 [label=&quot;false&quot;];
  closeParen1 [label=&quot;)&quot;];
  openCurley1 [label=&quot;{&quot;];
  Statement2 [label=&quot;Statement&quot;];
  var2 [label=&quot;var&quot;];
  zombie2 [label=&quot;zombie&quot;];
  assign2 [label=&quot;=&quot;];
  Expression2 [label=&quot;Expression&quot;];
  true2 [label=&quot;true&quot;];
  endStatement2 [label=&quot;;&quot;];
  closeCurley1 [label=&quot;}&quot;];
  closeCurley0 [label=&quot;}&quot;];
}</p></object>
</div>
<div class="section" id="ambiguity">
<h2>Ambiguity<a class="headerlink" href="Grammars.html#ambiguity" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>A grammar is ambiguous if there are multiple parse trees that exist for a single input</li>
<li>Ambiguity is generally a sign that something will go wrong in parsing your language</li>
<li>In the following example the Integer token is a sequence of digits from the tokenizer (literal)</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Expression</span> <span class="o">=</span> <span class="n">Expression</span> <span class="o">&lt;</span><span class="n">Minus</span><span class="o">&gt;</span> <span class="n">Expression</span>
           <span class="o">|</span> <span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Derive a parse tree from the following input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">8</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">-</span> <span class="mi">1</span>
</pre></div>
</div>
<ul class="simple">
<li>We could parse this input with (8 - 6) first or with (6 - 1) first.</li>
<li>The correct version is (8 - 6) based on our knowledge of arithmetic</li>
<li>Our grammar is ambiguous and allows for both definitions</li>
<li>The <em>leftmost</em> derivation is where we expand left <em>non-terminals</em> first</li>
<li>The <em>rightmost</em> derivation is where we expand right <em>non-terminals</em> first</li>
</ul>
<p>The <em>leftmost</em> derivation is the (8 - 6) derivation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Expression</span>  <span class="o">=&gt;</span> <span class="n">Expression</span> <span class="s2">&quot;-&quot;</span> <span class="n">Expression</span>                    <span class="o">//</span> <span class="n">Starting</span> <span class="n">rule</span>
            <span class="o">=&gt;</span> <span class="p">(</span><span class="n">Expression</span> <span class="s2">&quot;-&quot;</span> <span class="n">Expression</span><span class="p">)</span> <span class="s2">&quot;-&quot;</span> <span class="n">Expression</span>   <span class="o">//</span> <span class="n">Expand</span> <span class="n">the</span> <span class="n">LEFMOST</span> <span class="n">Expression</span>
            <span class="o">=&gt;</span> <span class="p">(</span><span class="n">Integer</span> <span class="s2">&quot;-&quot;</span> <span class="n">Expression</span><span class="p">)</span> <span class="s2">&quot;-&quot;</span> <span class="n">Expression</span>      <span class="o">//</span> <span class="n">Expand</span> <span class="n">the</span> <span class="n">LEFMOST</span> <span class="n">Expression</span>
            <span class="o">=&gt;</span> <span class="p">(</span><span class="s2">&quot;8&quot;</span> <span class="s2">&quot;-&quot;</span> <span class="n">Expression</span><span class="p">)</span> <span class="s2">&quot;-&quot;</span> <span class="n">Expression</span>          <span class="o">//</span> <span class="n">Expand</span> <span class="n">Integer</span>
            <span class="o">=&gt;</span> <span class="p">(</span><span class="s2">&quot;8&quot;</span> <span class="s2">&quot;-&quot;</span> <span class="n">Integer</span><span class="p">)</span> <span class="s2">&quot;-&quot;</span> <span class="n">Expression</span>             <span class="o">//</span> <span class="n">Expand</span> <span class="n">the</span> <span class="n">LEFMOST</span> <span class="n">Expression</span>
            <span class="o">=&gt;</span> <span class="p">(</span><span class="s2">&quot;8&quot;</span> <span class="s2">&quot;-&quot;</span> <span class="s2">&quot;6&quot;</span><span class="p">)</span> <span class="s2">&quot;-&quot;</span> <span class="n">Expression</span>                 <span class="o">//</span> <span class="n">Expand</span> <span class="n">Integer</span>
            <span class="o">=&gt;</span> <span class="p">(</span><span class="s2">&quot;8&quot;</span> <span class="s2">&quot;-&quot;</span> <span class="s2">&quot;6&quot;</span><span class="p">)</span> <span class="s2">&quot;-&quot;</span> <span class="n">Integer</span>                    <span class="o">//</span> <span class="n">Expand</span> <span class="n">the</span> <span class="n">LEFMOST</span> <span class="n">Expression</span>
            <span class="o">=&gt;</span> <span class="p">(</span><span class="s2">&quot;8&quot;</span> <span class="s2">&quot;-&quot;</span> <span class="s2">&quot;6&quot;</span><span class="p">)</span> <span class="s2">&quot;-&quot;</span> <span class="s2">&quot;1&quot;</span>                        <span class="o">//</span> <span class="n">Expand</span> <span class="n">Integer</span>
</pre></div>
</div>
<ul class="simple">
<li>We use parentheses to make it clear which <em>non-terminal</em> we are expanding</li>
<li>Is <code class="docutils literal"><span class="pre">Expression</span> <span class="pre">&quot;-&quot;</span> <span class="pre">Expression</span></code> to <code class="docutils literal"><span class="pre">Expression</span> <span class="pre">&quot;-&quot;</span> <span class="pre">Expression</span> <span class="pre">&quot;-&quot;</span> <span class="pre">Expression</span></code> left or right? (parentheses help!)</li>
</ul>
<p>And the <em>leftmost</em> parse tree:</p>
<object data="_images/graphviz-8cce18db32a3c3601da8809c88fa54d735813a2c.svg" type="image/svg+xml">
            <p class="warning">digraph
{
  node [fontsize=10, fontname=Verdana, shape=rectangle, margin=0.1, width=0.35, height=0.35];
  edge [fontsize=10, fontname=Verdana];

  Expression0 -&gt; Expression1;
  Expression1 -&gt; Integer0;
  Integer0 -&gt; 8;
  Expression1 -&gt; minus0;
  Expression1 -&gt; Integer1;
  Integer1 -&gt; 6;

  Expression0 -&gt; minus1;
  Expression0 -&gt; Expression2;
  Expression2 -&gt; Integer2;
  Integer2 -&gt; 1;

  Expression0 [label=&quot;Expression&quot;];
  Expression1 [label=&quot;Expression&quot;];
  Integer0 [label=&quot;Integer&quot;];
  minus0 [label=&quot;-&quot;];
  Integer1 [label=&quot;Integer&quot;];
  minus1 [label=&quot;-&quot;];
  Expression2 [label=&quot;Expression&quot;];
  Integer2 [label=&quot;Integer&quot;];
}</p></object>
<p>The <em>rightmost</em> derivation is the (6 - 1) derivation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Expression</span>  <span class="o">=&gt;</span> <span class="n">Expression</span> <span class="s2">&quot;-&quot;</span> <span class="n">Expression</span>                    <span class="o">//</span> <span class="n">Starting</span> <span class="n">rule</span>
            <span class="o">=&gt;</span> <span class="n">Expression</span> <span class="s2">&quot;-&quot;</span> <span class="p">(</span><span class="n">Expression</span> <span class="s2">&quot;-&quot;</span> <span class="n">Expression</span><span class="p">)</span>   <span class="o">//</span> <span class="n">Expand</span> <span class="n">the</span> <span class="n">RIGHTMOST</span> <span class="n">Expression</span>
            <span class="o">=&gt;</span> <span class="n">Expression</span> <span class="s2">&quot;-&quot;</span> <span class="p">(</span><span class="n">Expression</span> <span class="s2">&quot;-&quot;</span> <span class="n">Integer</span><span class="p">)</span>      <span class="o">//</span> <span class="n">Expand</span> <span class="n">the</span> <span class="n">RIGHTMOST</span> <span class="n">Expression</span>
            <span class="o">=&gt;</span> <span class="n">Expression</span> <span class="s2">&quot;-&quot;</span> <span class="p">(</span><span class="n">Expression</span> <span class="s2">&quot;-&quot;</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>          <span class="o">//</span> <span class="n">Expand</span> <span class="n">Integer</span>
            <span class="o">=&gt;</span> <span class="n">Expression</span> <span class="s2">&quot;-&quot;</span> <span class="p">(</span><span class="n">Integer</span> <span class="s2">&quot;-&quot;</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>             <span class="o">//</span> <span class="n">Expand</span> <span class="n">the</span> <span class="n">RIGHTMOST</span> <span class="n">Expression</span>
            <span class="o">=&gt;</span> <span class="n">Expression</span> <span class="s2">&quot;-&quot;</span> <span class="p">(</span><span class="s2">&quot;6&quot;</span> <span class="s2">&quot;-&quot;</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>                 <span class="o">//</span> <span class="n">Expand</span> <span class="n">Integer</span>
            <span class="o">=&gt;</span> <span class="n">Integer</span> <span class="s2">&quot;-&quot;</span> <span class="p">(</span><span class="s2">&quot;6&quot;</span> <span class="s2">&quot;-&quot;</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>                    <span class="o">//</span> <span class="n">Expand</span> <span class="n">the</span> <span class="n">RIGHTMOST</span> <span class="n">Expression</span>
            <span class="o">=&gt;</span> <span class="s2">&quot;8&quot;</span> <span class="s2">&quot;-&quot;</span> <span class="p">(</span><span class="s2">&quot;6&quot;</span> <span class="s2">&quot;-&quot;</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>                        <span class="o">//</span> <span class="n">Expand</span> <span class="n">Integer</span>
</pre></div>
</div>
<p>And the <em>rightmost</em> parse tree:</p>
<object data="_images/graphviz-28890857af607f3eff8f83a2d874061d76bee5cd.svg" type="image/svg+xml">
            <p class="warning">digraph
{
  node [fontsize=10, fontname=Verdana, shape=rectangle, margin=0.1, width=0.35, height=0.35];
  edge [fontsize=10, fontname=Verdana];

  Expression0 -&gt; Expression1;
  Expression1 -&gt; Integer2;
  Integer2 -&gt; 8;
  Expression0 -&gt; minus1;
  Expression0 -&gt; Expression2;

  Expression2 -&gt; Integer0;
  Integer0 -&gt; 6;
  Expression2 -&gt; minus0;
  Expression2 -&gt; Integer1;
  Integer1 -&gt; 1;

  Expression0 [label=&quot;Expression&quot;];
  Expression1 [label=&quot;Expression&quot;];
  Integer0 [label=&quot;Integer&quot;];
  minus0 [label=&quot;-&quot;];
  Integer1 [label=&quot;Integer&quot;];
  minus1 [label=&quot;-&quot;];
  Expression2 [label=&quot;Expression&quot;];
  Integer2 [label=&quot;Integer&quot;];
}</p></object>
<ul class="simple">
<li>These two parse trees are very similar to an <em>expression tree</em></li>
<li>An <em>expression tree</em> is a sub-tree of the <em>Abstract Syntax Tree</em></li>
<li>An expression tree is evaluated from bottom to top</li>
<li>Leafs must be values or literals</li>
<li>Parents must be binary or unary operators</li>
<li>The <em>leftmost</em> derivation gives <code class="docutils literal"><span class="pre">(8</span> <span class="pre">-</span> <span class="pre">6)</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">=&gt;</span> <span class="pre">1</span></code> (correct)</li>
<li>The <em>rightmost</em> derivation gives <code class="docutils literal"><span class="pre">8</span> <span class="pre">-</span> <span class="pre">(6</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">=&gt;</span> <span class="pre">3</span></code> (incorrect)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Exercise: Trace the path of evaluation around the <em>expression tree</em></p>
</div>
<p>Another classic case for ambiguity comes with single line if statements (without scope). Given the grammar:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Statement</span>   <span class="o">=</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;(&quot;</span> <span class="n">Expression</span> <span class="s2">&quot;)&quot;</span> <span class="n">Statement</span> <span class="s2">&quot;else&quot;</span> <span class="n">Statement</span>
            <span class="o">|</span> <span class="s2">&quot;if&quot;</span> <span class="s2">&quot;(&quot;</span> <span class="n">Expression</span> <span class="s2">&quot;)&quot;</span> <span class="n">Statement</span>
            <span class="o">|</span> <span class="s2">&quot;var&quot;</span> <span class="n">Identifier</span> <span class="s2">&quot;=&quot;</span> <span class="n">Expression</span> <span class="s2">&quot;;&quot;</span>
<span class="n">Expression</span>  <span class="o">=</span> <span class="s2">&quot;true&quot;</span> <span class="o">|</span> <span class="s2">&quot;false&quot;</span>
</pre></div>
</div>
<p>The following code actually has two derivations. This is the <em>leftmost</em> derivation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">true</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">false</span><span class="p">)</span>
    <span class="n">var</span> <span class="n">zombie</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">var</span> <span class="n">headcrab</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
</pre></div>
</div>
<p>The <em>rightmost</em> derivation we can represent simply through manipulation of whitespace (very confusing to new programmers!):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">true</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">false</span><span class="p">)</span>
    <span class="n">var</span> <span class="n">zombie</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
<span class="k">else</span>
  <span class="n">var</span> <span class="n">headcrab</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Even if an ambiguity can be resolved in a grammar, it may still confuse a user of your language. Keywords at the beginning of different types of statements is a good way to let the user know unambiguously what is happening.</p>
</div>
<div class="section" id="classic-examples-of-ambiguity">
<h3>Classic Examples of Ambiguity<a class="headerlink" href="Grammars.html#classic-examples-of-ambiguity" title="Permalink to this headline">¶</a></h3>
<p>In C it is legal to declare/extern a function within the definition of another function (extern is optional). You could write:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">MyFunction</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">OtherFunction</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C++ added the ability to invoke constructors of variables defined on the stack.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">MyFunction</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">MyType</span> <span class="n">StackVariable</span><span class="p">(</span><span class="n">argument</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Without looking to see whether <code class="docutils literal"><span class="pre">argument</span></code> is a type or a local variable, there is no way to know if this is a extern function declaration or a stack variable. This is especially problematic in this case:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">MyFunction</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">something</span> <span class="n">Something</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C++ has no way of knowing in this case, so the behaviour is defined to always be an extern declaration. Technically this is ok because you don&#8217;t need to manually invoke the default constructor, but as mentioned before, this can be <strong>confusing</strong> to new users of the language. It is best to design your language without these ambiguities.</p>
<p>Another example in C++:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">collider</span> <span class="o">=</span> <span class="n">Collider</span><span class="o">&lt;</span><span class="n">Sphere</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>Even advanced users of C++ will most likely look at this line and see a template instantiation of type <code class="docutils literal"><span class="pre">Collider</span></code> where the template type is <code class="docutils literal"><span class="pre">Sphere</span></code>, passing <code class="docutils literal"><span class="pre">true</span></code> to the constructor.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Collider</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">Sphere</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</pre></div>
</div>
<p>Surprise! The operators &lt; and &gt; exist for bool types. The <code class="docutils literal"><span class="pre">(true)</span></code> is just an expression wrapped in grouping parentheses.</p>
</div>
</div>
<div class="section" id="elimination-of-ambiguity">
<h2>Elimination of Ambiguity<a class="headerlink" href="Grammars.html#elimination-of-ambiguity" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>We can treat the if-else case similar to how we treated the order of edges in the DFA</li>
<li>When we implement the if-else grammar, just be sure to always use the <em>leftmost</em> derivation</li>
<li>In other words always pair the else with the closest if</li>
<li>There is no general algorithm for doing this: the details depend upon your language design</li>
<li>For the <code class="docutils literal"><span class="pre">Expression</span> <span class="pre">&quot;-&quot;</span> <span class="pre">Expression</span></code> we can apply associativity rules to make it unambiguous</li>
</ul>
</div>
<div class="section" id="left-recursion">
<h2>Left Recursion<a class="headerlink" href="Grammars.html#left-recursion" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Any grammar that has a recursive <em>non-terminal</em> on the left side of a production is considered <em>left recursive</em></li>
<li>A good example of left recursion:</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">List</span>  <span class="o">=</span> <span class="n">List</span> <span class="s2">&quot;,&quot;</span> <span class="n">Identifier</span>
      <span class="o">|</span> <span class="n">Identifier</span>
</pre></div>
</div>
<ul class="simple">
<li>The style of parser we&#8217;ll be using later is known as a <em>recursive descent</em> parser</li>
<li>Rules like this would literally translate into function calls:</li>
</ul>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">List</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">List</span><span class="p">();</span>
  <span class="n">Accept</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>The primary issue we have here is that List immediately recurses into itself</li>
<li>An infinite recursion that will blow the stack</li>
</ul>
<p>In general, we can take any <em>left recursive</em> rule written in the form of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="n">x</span> <span class="o">|</span> <span class="n">B</span>
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">A</span></code> is a <em>non-terminal</em></li>
<li><code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are can be <em>terminals</em> or <em>non-terminals</em> but they must not start with <code class="docutils literal"><span class="pre">A</span></code></li>
<li>Think about what can be parsed with this grammar</li>
<li>Either just <code class="docutils literal"><span class="pre">B</span></code> alone, or we could start with <code class="docutils literal"><span class="pre">A</span> <span class="pre">x</span></code> and recurse into <code class="docutils literal"><span class="pre">A</span></code> again</li>
<li>This leads to <code class="docutils literal"><span class="pre">Bxxxxx...</span></code></li>
<li>What&#8217;s another way we could refactor this same grammar to be</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">B</span> <span class="n">R</span> <span class="o">|</span> <span class="n">B</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">x</span> <span class="n">R</span> <span class="o">|</span> <span class="n">x</span>
</pre></div>
</div>
<ul class="simple">
<li>Notice how this same grammar produces either just <code class="docutils literal"><span class="pre">B</span></code> or <code class="docutils literal"><span class="pre">Bxxxxx...</span></code></li>
<li>We could also use the special <em>epsilon</em> rule (empty token)</li>
<li>This rule is often denoted as either <code class="docutils literal"><span class="pre">&quot;&quot;</span></code> in EBNF or in many grammars as a the epsilon symbol ϵ</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">B</span> <span class="n">R</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">x</span> <span class="n">R</span> <span class="o">|</span> <span class="s2">&quot;&quot;</span>
</pre></div>
</div>
<ul class="simple">
<li>The <em>epsilon</em> can always be eliminated from a grammar</li>
<li>In the <em>recursive descent</em> implementation, the <em>epsilon</em> requires special handling</li>
<li>Using the first refactor (without <em>epsilon</em>) we can rewrite the List grammar as:</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">List</span>    <span class="o">=</span> <span class="n">Identifier</span> <span class="n">ListEnd</span>
        <span class="o">|</span> <span class="n">Identifier</span>
<span class="n">ListEnd</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span> <span class="n">Identifier</span> <span class="n">ListEnd</span>
        <span class="o">|</span> <span class="s2">&quot;,&quot;</span> <span class="n">Identifier</span>
</pre></div>
</div>
<p>Recommended reading:</p>
<blockquote>
<div><ul class="simple">
<li>Section 2.2 of <em>Compilers: Principles, Techniques, and Tools</em> describes grammars in more detail</li>
<li>Section 4.3 of <em>Compilers: Principles, Techniques, and Tools</em> describes elimination of ambiguity, left recursion, and left factoring</li>
</ul>
</div></blockquote>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Operators.html" class="btn btn-neutral float-right" title="Operators" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="RegularExpressions.html" class="btn btn-neutral" title="Regular Expressions" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, DigiPen Institute of Technology.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>