Assignment 4
============
`Download The Assignment <../CS375Assignments/Assignment4.zip>`_

The goal of the fourth assignment is to run *Semantic Analysis* over the AST to verify that all types are correct and constructs are properly used.

- All of the code must be implemented within ``User4.cpp`` inside the ``UserCode`` directory
- Extra headers (.h/.hpp) can be submitted to the grading server
- This assignment requires ``User1.cpp`` and ``User3.cpp`` from the previous assignments

- The reference executable (sample driver) is provided in the ``Reference`` folder

  - Run a particular test by passing in a number to the command line
  - No arguments means run all tests

- The score you get for the assignment is the number of passed tests out of the total number of tests
- It is up to you to run *diff* or any similar differencing tool to verify that your code matches the reference executable

- Requires Visual Studio 2015

- The Visual Studio .sln is located within the ``CompilerClassAssignment4`` directory
  
- Please read all the comments above each of the driver functions that you must implement

- Submit your assignment using the online server at: :ref:`assignment-submission`

Implementation
--------------
- You will be performing a minimum of 4 Visitor passes over the AST
- You will be given an array of ``Libraries`` that the code you are compiling depends upon
- This always includes the **core** library with language primitives
- The driver globally externs pointers to the **core** library Types

  - ``VoidType``, ``NullType``, ``IntegerType``, ``FloatType``, ``BooleanType``, and ``ByteType``

- Dependent libraries only ever add global symbols

  - The assignment tests guarantee that symbols from two different libraries will not conflict (handle that in your own compiler!)

- **Limitations:**

  - Members are not implicit (do not push them onto your scope stack)
  - All functions require returns (we are not analyzing control flow or adding implicit Void returns)
  - To simplify this assignment we are not tracking L/R values or adding references e.g. ``Integer&``
  - We are also not handling function pointer declarations
  
The passes you are required to implement:

1)
  - Visit ClassNodes and create global Type symbols
  
    - Types are always globals (not nested)
    - No need for a scope stack
    - Throw ErrorSameName for duplicate global names
    - (Optional) use this opportunity to setup mParent pointers for nodes

2)
  - Visit TypeNodes and resolve all types (including pointers)
  
    - Types are always globals (not nested)
    - Must resolve our own types as well as library dependencies
    - Scope stack technically not needed, but may be used (with one global entry)
    - Throw ErrorSymbolNotFound if we cannot find a Type
    - Throw ErrorIncorrectSymbolType if symbol is not 'Type' (e.g. Print)
    
  - Visit FunctionNodes and create the signature types via GetFunctionType
  
    - Fill out the Type* on the FunctionNode (used later)

3)
  - Visit Function/Variable/Label nodes and create symbols for them
  
    - Must figure out if a symbol should be globally exposed on a library
    - Must correctly add symbol as class member or function local
    - Must maintain parent pointers
    - Must setup Function's signature type from previous pass
    - Throw ErrorSameName for duplicate class member names
    - Throw ErrorSameName for duplicate label names

4)
  - Visit all Statement/Expression nodes and perform type checking on them
  
    - See the behaviors listed below in *Pass 4*
    
- Part 1 tests the first 3 passes without errors (types and symbol creation)
- Part 2 tests the first 3 passes with errors
- Part 3 tests all 4 passes (expressions) without errors
- Part 4 tests all 4 passes (expressions) with errors

- Implement the following functions within ``Driver4.hpp`` in your ``User4.cpp`` (*read comments*):

  - ``SemanticAnalyize`` will run analysis over the using the 4 passes
  - ``PrintTreeWithSymbols`` will implement a separate print visitor (like assignment 3) that also prints out symbol information

- Implement the following functions within ``SymbolTable.hpp`` in your ``User4.cpp`` (*read comments*):

  - ``CreateType``, ``CreateVariable``, ``CreateFunction``, ``CreateLabel`` must allocate the symbol of a particular type (also tracks it with the library)
  - ``GetPointerType`` gets a pointer from a given type
  - ``GetFunctionType`` get a function symbol for the given types and return value
  - Take care to respect normalized names (printed by the driver)
  - Pointers have no spaces within their names and append the number of pointers at the end: e.g. ``Integer*``, ``Byte**``
  - Functions start with the keyword ``function`` followed by parentheses with all argument types. The argument types are separated by a comma and space ``, ``: e.g. ``function(Integer, Byte)``, ``function(Byte)``

- Use the driver provided ``NodePrinter`` (inherits from ``std::stringstream`` to allow you to use ``<<``)
- Works directly with emitting Symbol*/Symbol& as well as Tokens
- Printing a null Symbol* is valid and will print ``(nullptr)``
- The default behavior of each node should be to print its class name, e.g. ``ContinueNode``
- The following nodes must print using the given format:

::
  
  ClassNode(mSymbol)
  VariableNode(mSymbol)
  ParameterNode(mSymbol)
  FunctionNode(mSymbol)
  TypeNode(mSymbol)
  LabelNode(mSymbol)
  GotoNode(mResolvedLabel)
  ExpressionNode(mResolvedType)
  LiteralNode(mToken, mResolvedType)
  NameReference(mName, mResolvedType)
  BinaryOperatorNode(mOperator, mResolvedType)
  UnaryOperatorNode(mOperator, mResolvedType)
  PostExpressionNode(mResolvedType)
  MemberAccessNode(mOperator, mResolvedMember, mResolvedType)
  CallNode(mResolvedType)
  CastNode(mResolvedType)
  IndexNode(mResolvedType)

- Highly recommended that you implement helper functions, macros, and templates to simplify your code
- **All Error functions are provided within the ``Driver4.hpp`` and must be called for each error situation**
- Always be sure to check the AST Nodes to see if there is anything that must be filled out by *Semantic Analysis*

Pass 4
------

.. note:: When in doubt, let the driver guide you to the implementation (or generally try to follow C/C++ operators/statements)

LiteralNode
```````````
The following tokens result in the following types:

- IntegerLiteral -> Integer
- FloatLiteral -> Float
- StringLiteral -> Byte*
- CharacterLiteral -> Byte
- True/False -> Boolean
- Null -> Null*

NameReferenceNode
`````````````````
- Must use the symbol stack to identify the symbol it is refering to
- It may only refer to a Function or Variable symbol

IndexNode
`````````
- Only valid on Pointer

MemberAccessNode
````````````````
- ``.`` is only allowed on Class types
- ``->`` is only allowed on Pointers to Class types (single pointer)

BinaryOperatorNode
``````````````````
- ``+`` ``-`` ``*`` ``/`` ``%`` are valid for Byte, Integer, Float (same types only, requires casting, results in same type)
- ``+`` ``-`` are also valid between Integer and Pointer (and visa versa, results in Pointer)
- ``-`` is valid between Pointer and Pointer (results in Integer)
- ``<`` ``>`` ``<=`` ``>=`` ``==`` ``!=`` are valid for all types (results in Boolean)
- ``&&`` ``||`` are valid for Boolean and Pointer (results in Boolean)
- ``=`` is valid for all types except Function (same types only, note Function* is ok!)
- Compound operators are left unhandled/untested

.. warning:: And, Or are parsed keywords by our tokenizer and are NOT the same as LogicalAnd/LogicalOr

UnaryOperatorNode
`````````````````
- You must add parsing for the unary ``BitwiseAndAddressOf`` and ``Plus`` to your parser (Grammar.txt has been updated)
- ``*`` is only allowed on Pointer (results in dereferenced type)
- ``+`` ``-`` are valid for Byte, Integer, Float (results in same type)
- ``++`` ``--`` are valid for Pointer, Byte, Integer, Float (results in same type)
- ``!`` is valid for Boolean and Pointer (results in Boolean)
- ``&`` is valid for all types (results in Pointer to that type)

.. warning:: Not is a parsed keyword by our tokenizer and is NOT the same as LogicalNot

CallNode
````````
- Only valid on Function types

CastNode
````````
- Integer, Float, Boolean, Byte can all be cast to each other
- Pointers can always be cast to any other type of Pointer (reinterpret)
- Function types cannot be cast (but Pointers to Functions can)
- Integer to Pointer / Pointer to Integer
- Pointer to Boolean

IfNode/ForNode/WhileNode
````````````````````````
- Condition must be of type Boolean or Pointer

GotoNode
````````
- Must find another label within the same function level scope
- Can jump backwards or within any nested scope (or out of)
- Labels are function level scoped

ReturnNode
``````````
- Needs to know which function it is within
- Verifies that the return expression matches the parent function's return value
- Only allow null expression if return type is Void

ParameterNode/VariableNode
``````````````````````````
- **ParameterNode is now inherited from VariableNode and the Visitor must be updated**
- Must create a ``Variable`` symbol to represent it
