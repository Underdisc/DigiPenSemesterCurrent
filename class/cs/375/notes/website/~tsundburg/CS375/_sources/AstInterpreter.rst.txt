
AST Interpreter
===============
- After the Semantic Analysis phase
- The most basic and easiest form of code execution
- In a static language all symbols have been collected prior (via Semantic Analysis)

  - All the variables and name references have been linked up
  - Goto statements should know where their target label is

- Use the visitor to walk the tree and compute results
- Most visit functions will return **Stop** because we manually walk the children
- Can use an entirely dynamic runtime (variants, tables/objects)

  - To some extent, this is encouraged with a scripting language
  - Easy to patch, redefine objects, reload code

- More difficult to use a static runtime (memory stack, registers, global addresses)
- Never performed any code generation or pre-computing

  - Jump locations
  - Register usage
  - Stack sizes
  - Struct layouts

- May perform a **pre-pass** over the tree to simplify execution

Advantages
----------
- Easy to implement
- Faster to 'fully compile' due to no code generation
- Portable: All machines that can compile C++ can run your interpreter

Disadvantages
-------------
- Orders of magnitude slower than machine code
- Not many opportunities for optimization
- Can be larger in memory than machine code if the full tree is stored
- Recursive visitors become a problem (recursion depth)

  - Every function called increases recursion depth for the Visitor

- Arbitrary jumps (such as gotos) are difficult to implement

Execution
---------
- Each node has its own behavior for what it does
- Interpreter is mostly just executing functions
- A 'function' is really just a ``FunctionNode`` (Walk and execute the child statements)

Expressions
```````````
- A static runtime would have each expression place arguments at a computed position on a stack (or within registers)
- When using a dynamic runtime, each expression results in a ``Variant``
- Can push results to a ``Variant`` stack: ``std::vector<Variant>``

  - At the end of visiting an expression node it will push a single variant to the stack
  - Nodes pop their arguments from the stack (``BinaryNode`` would pop 2, ``UnaryNode`` would pop 1)

- Because we are using a Visitor we can just store ``Variant`` results on our own C++ stack
- Expression results can just be returned through a single member on the visitor ``Variant mResult;``

.. code-block:: cpp

  class InterpreterVisitor : public Visitor
  {
  public:
    // The resulting value from any expression (a literal, function call return, etc)
    // Before we visit another child expression we should store this on our C++ stack
    // Variant result = mResult;
    Variant mResult;
    
    //...
  };

- The variant must be able represent all primitive types

.. code-block:: cpp

  enum VariantType
  {
    Pointer,
    Boolean,
    Integer,
    Float,
    String,
    Table
  };

  class Variant
  {
  public:
    // What type is this variant currently storing? (typically defaults to null or undefined)
    VariantType mType;
  
    Variant* mPointer;
    bool mBoolean;
    int mInteger;
    float mFloat;
    std::string mString;
    std::unordered_map<Variant, Variant> mTable;
  };

Literals
''''''''
- Construct a ``Variant`` to represent the value stored
- Typically requires conversion from original input string format to numerical values
- String literals escapes should be converted to their real ASCII or Unicode values
- May want to perform all theses steps on the Literal or Value node in Semantic Analysis

  - Or as a one time pre-pass (cache ``Variant`` on the ``LiteralNode`` itself)
  - Avoids extra computation when using an AST Interpreter
  - Typically done within a code generator visitor for other styles of execution (byte / machine code, etc)

.. code-block:: cpp

  VisitResult Visit(LiteralNode* node) override
  {
    switch (node->mToken.mType)
    {
      case TokenType::IntegerLiteral
        mResult.mType = Integer;
        mResult.mInteger = atoi(node->mToken.mText);
        break;
      case TokenType::StringLiteral
        mResult.mType = String;
        
        // This function may strip the quotes from
        // the ends as well as process escape codes
        mResult.mString = StringEscape(node->mToken.mText, node->mToken.mLength);
        break;
      //...
    }
    return Stop;
  }
  
  
Binary Operators
''''''''''''''''
- Walk the left child: the result will be stored in ``mResult``
- Copy the result to your local C++ stack: ``Variant left = mResult``
- Walk the right child: the result will be stored in ``mResult``
- Copy the result to your local C++ stack: ``Variant right = mResult``

  - We don't technically need to copy because ``BinaryNode`` has no other children to visit
  - It just looks nice

- Switch upon the operation you are supposed to perform
- Should have been determined by Semantic Analysis

.. code-block:: cpp

  VisitResult Visit(BinaryNode* node) override
  {
    node->mLeft->Walk(this);
    Variant lhs = mResult;
    
    node->mRight->Walk(this);
    Variant rhs = mResult;
    
    // A clever Semantic Analysis phase could have picked out a function
    // pointer to resolve this operator, for example 'int + int' would be:
    // Variant IntegerAdd(Variant& lhs, Variant& rhs);
    // We could simply invoke that function pointer here
    
    // We may also want to make the guarantee that we'll only ever perform operations
    // between the same types, and that it is either illegal or implicit casting would occur
    // to prevent operations between dissimilar types
    
    switch (node->mOperator.mType)
    {
      case TokenType::Plus:
        
        // Assume both lhs and rhs are the same type
        switch (lhs.mType)
        {
          case VariantType::Integer:
            mResult.mType = VariantType::Integer;
            mResult.mInteger = lhs.mInteger + rhs.mInteger;
            break;
            
          //...
        }
        break;
        
        //...
    }
    
    // It is very important that we return STOP here because
    // we already visited our own children and we
    // do not want to automatically visit children
    return Stop;
  }

Unary Operators
'''''''''''''''
- Same as the binary node case but with only one argument
- Don't need to store any locals technically

Type Casting
''''''''''''
- Walk the operand expression node
- Switch first on the type stored within ``mResult``
- Switch second on the type we're casting to
- Can also be optimized by pre-computing function pointers in a pre-pass or Semantic Analysis

Member Access
'''''''''''''
- Walk the left expression node
- The left expression must either be a dynamic table or a pointer

  - Verified by the Semantic Analysis phase
  - Good practice to use asserts to double verify

- Index the left expression by name via ``std::unordered_map<Variant, Variant>``
- The ``mResult`` becomes the value ``Variant`` from the ``unordered_map``

.. code-block:: as

  // At a high level, we assume CreatePlayer is allocating a structure
  // Using a dynamic runtime, CreatePlayer will most likely allocate a Variant
  // and then return a Variant pointer to it
  var player : Player* = CreatePlayer();
  
  // 'player' is a name reference node which resolves to the above variable (Variant of type Pointer)
  // '->Lives' is a member access node
  // The -> means the left hand side must be a pointer (verified by SemanticAnalysis)
  // Therefore, the runtime can always *assume* that the left 'player' is a Variant of type Pointer
  // In particular, we know its pointing at another Variant of type Table
  // Dereference the pointer and then index the table with string 'Lives'
  player->Lives = 9;

If Statements
'''''''''''''
- Directly utilizes an if statement within the implementing language (C++)
- If we have a *conditional expression* then walk it
- Boolean result should be stored in ``mResult``
- If **true** then visit the ``ScopeNode`` for that if
- If **false** then visit the ``Else`` node recursively 
- No *conditional expression* means that we're a final ``Else`` node

  - Just walk our ``ScopeNode`` statements instead

.. code-block:: as

  if (A)
  {
    //...
  }
  else if (B)
  {
    //...
  }
  else // C
  {
    //...
  }


.. code-block:: cpp

  VisitResult Visit(IfNode* node) override
  {
    // Do we have a condition?
    if (node->mCondition != nullptr)
    {
      // Walk the condition which should result in a bool
      // (or pointer value if your language allows this)
      node->mCondition->Walk(this);
      
      // Should we run our statements?
      if (mResult.mBoolean)
      {
        node->mScope->Walk(this);
      }
      else
      {
        // Run the 'else' recursively which may have its own condition...
        node->mElse->Walk(this);
      }
    }
    else
    {
      // This is a final else statement, just run all our scopes
      node->mScope->Walk(this);
    }
    
    // We visited our children manually, no need to auto walk them
    return Stop;
  }
  
.. graphviz::

  digraph
  {
    node [shape=rectangle, fontsize=10, height=0.2, fontname=Verdana];
    "[If]\nA" -> "[Name]\nA";
    "[If]\nA" -> "[ScopeNode]\nA...";
    "[If]\nA" -> "[If]\nB";
    
    "[If]\nB" -> "[Name]\nB";
    "[If]\nB" -> "[ScopeNode]\nB...";
    "[If]\nB" -> "[If]\nC";
    
    "[If]\nC" -> "[ScopeNode]\nC...";
  }

While, Do-While, For, Etc
'''''''''''''''''''''''''
- Similar to the above if statement
- Typically uses each C++ construct to emulate loops in your language
- Must handle **break** and **continue** specially (see below)
  
Return
''''''
- More difficult to implement
- Typically use flow control flags on the Visitor to let statement execution know it must return
- Has to return up all levels of execution

For a simple bit of code such as the following:

.. code-block:: as

  function Main()
  {
    var counter : Integer = 0;
    while (true)
    {
      if (counter < 10)
      {
        if (counter == 5)
        {
          return;
        }
      }
      ++counter;
    }
  }

Our call stack could look something like:

::

    Walk(FunctionNode)
    Walk(ScopeNode)
    Walk(WhileNode)
    Walk(ScopeNode)
    Walk(IfNode)
    Walk(ScopeNode)
    Walk(IfNode)
    Walk(ScopeNode)
    Walk(ReturnNode)

- We need to let every node know that it needs to exit without running any more statements
- We could always... **throw an exception** and catch it in our Visit for ``FunctionNode``
- Order upon orders of magnitude slower
- Instead write a custom visitor for ``ScopeNode``
- After visiting each statement we check for a ``mReturn`` flag on the Visitor and early out

Break and Continue
''''''''''''''''''
- Implemented the same as the above return control flow

  - Doesn't return beyond a looping constructor (or switch statement)
  - **Break** will exit ``ScopeNode`` statements and then exit the ``WhileNode``
  - **Continue** will exit ``ScopeNode`` statements and then restart the ``WhileNode`` condition / statements

- Can also be implemented via exceptions

Exceptions
''''''''''
- Throwing an exception in language typically just throws an actual C++ exception

  - C++ exception type typically just stores the Variant object

- Must be caught and re-thrown by function calls to ensure they properly pop the stack

Function Calls
''''''''''''''
- Via the ``CallNode``
- All expression nodes bubble values up
- One of the more difficult aspects to handle because it passes values to its children (down)
- Need a way to pass ``Variants`` in as the parameters
- Could pre-compute zero based indices for all the parameters and local variables

  - Relative to the base of the current stack frame

- Could also use more dynamic runtime and use a **table**
- Parameters and local variable *names* are mapped to their *values*
- The *table* represents a single stack frame
- Need a stack of tables on our visitor

.. code-block:: cpp

  // Before we call a function, we always push a new stack frame
  // Each Variant stored here is of type Table
  // The key is always a String and the value is anything
  // We could also store it in another format, but this allows for nice dynamic language features
  std::stack<Variant> mVariableStack;

- Calling a function is as simple as walking it (must have arguments on the stack first)

.. code-block:: cpp

  virtual VisitResult Visit(CallNode* node)
  {
    // First walk the left of the call operation
    node->mLeft->Walk();
      
    // Build a new stack frame for the function we're about to call (also pushes it onto the stack)
    Variant& mLocals = mVariableStack.emplace_back();
    mLocals.mType = VariantType::Table;
    
    // Look up the FunctionNode on the CallNode (resolved at Semantic Analysis phase)
    FunctionNode* functionNode = node->mFunctionNode;
    
    // Gather the results of all the call arguments
    size_t index = 0;
    for (ExpressionNode* expressionChild : node->mArguments)
    {
      // Make a string Variant from the parameter name
      Variant parameterName;
      parameterName.mType = VariantType::String;
      
      // We can get the name of the parameters for the function off the FunctionNode
      // Note: We don't even need to check if this index is valid!
      parameterName.mString = functionNode->mParameters[index]->mName.str();
      
      // Every time we walk an expression, it sets its result into mResult
      expressionChild->Walk(this);
      
      // We then store that result locally by name
      mLocals.mTable[parameterName] = mResult;
      ++index;
    }
    
    // Depending on the implementation, we may want to catch exceptions here
    // We could catch control flow exceptions for return, break, or continue (not recommended)
    // We could also catch actual exceptions thrown in language (we must pop our stack and rethrow)
    
    // Now walk the function node that we're going to call (generally only the statements)
    // The return value should be stored within ``mResult``
    functionNode->mScope->Walk(this);
    
    // Since we walked the function and its scope, we can pop the stack variables
    mVariableStack.pop_back();
  }

- May want to augment the ``Variant`` so that it may point at functions

.. code-block:: cpp

  enum VariantType
  {
    Function,
    //...
  };

  class Variant
  {
  public:
    FunctionNode* mFunction;
    //...
  };

- May need to handle **constructor calls** specially

Examples
--------
- Perform semantic analysis on the following parsed AST
- Simulate running an interpreter (and stack) with the input 5
- The interpreter should contain our result after running in ``mResult``

.. code-block:: as

  function Double(value : Integer) : Integer
  {
    return value * 2;
  }

.. graphviz::

  digraph
  {
    node [shape=rectangle, fontsize=10, height=0.2, fontname=Verdana];
    "[Function]\nDouble" -> "[Parameter]\namount";
    "[Parameter]\namount" -> "[Type]\nInteger";
    "[Function]\nDouble" -> "[Type]\nInteger ";
    "[Function]\nDouble" -> "[Return]";
    "[Return]" -> "[Binary]\n*";
    "[Binary]\n*" -> "[Name]\nvalue";
    "[Binary]\n*" -> "[Literal]\n2";
  }

- For the following code, build an AST and follow the same instructions above:

.. code-block:: as
 
  class Planet
  {
    var Mass : Double;
    
    function ComputeMass(density : Double, volume : Double)
    {
      this.Mass = density * volume;
    }
  }

  class Program
  {
    static function Main() : Integer
    {
      var earth = new Planet();
      earth->ComputeMass(10, 20.0);
      
      return 0;
    }
  }
