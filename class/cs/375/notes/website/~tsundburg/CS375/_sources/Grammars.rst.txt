.. |epsilon|  unicode:: U+03F5

.. Need to cover operator precedence and associativy with parse trees / derivations
.. Cover common refactors and using Regex

Grammars
========
- Programming languages are generally hierarchical
- A scoped statement can contain zero or more nested scoped statements
- We need a way to describe the *recursive* rules of parsing our language
- A *grammar* describes all the parsing rules for our language (can also be used for a lexer)
- There are many different existing formats for describing grammars (BNF, EBNF, etc)
- The grammar of an *if* statement might look something like the following

::

  Statement = <If> <OpenParentheses> Expression <CloseParentheses> <OpenCurley> Statement <CloseCurley>
            | <Var> <Identifier> <Assignment> Expression <Semicolon>

- We left off the definition of Expression for simplicity
- Any token wrapped in <> comes from our Tokenizer (the enum value)
- In any grammar, the tokens are formally referred to as a *terminal*
- ``Statement``, ``Expression`` are *non-terminals*
- The equals sign after ``Statement`` is referred to as a *production* or rule
- The *or* symbol ``|`` can be used to define multiple rules for a *production*
- Whitespace and newlines are irrelevant in our grammar definition

You might also see that same grammar defined with EBNF:

::

  Statement = "if" "(" Expression ")" "{" Statement "}"
            | "var" Identifier "=" Expression ";"

- EBNF assumes you are defining everything about your language, including token semantics
- There is no formal way to specify that a token came from a previous phase, such as a tokenizer

::

  MatchingParenthesis = <OpenParentheses> MatchingParenthesis <CloseParentheses>
                      | <OpenParentheses> <CloseParentheses>

- The recursive nature of grammars allows us to do more than a DFA
- Try and create a DFA that allows for an infinite number of matching ``(`` and ``)``
- E.g. ``()``  or ``(())`` or ``(((())))``
- With a grammar, this is trivial
- As with all things recursion, we need a base case, hence the ``<OpenParentheses> <CloseParentheses>``

Similarity To Regular Expressions
---------------------------------
- The only major difference between grammars and regular expressions is recursion
- We can apply the same operators and algebra to a grammar
- ``<Static> <Var> | <Static> <Function>`` can be factored into ``<Static> (<Var> | <Function>)``

  - Using the *distributive* property (more importantly the reverse which is left factoring)

- We can also use all the other operators, such as \*, +, ?, grouping (), epsilon |epsilon|, etc
- This does make it convenient to also write the token grammar along with the language grammar

  - Recommended that you separate the token grammar from parser grammar

- Concatenation (two <Terminals> next to each other) is still the highest precedence
  
We can rewrite the above matching parentheses rule in a few different ways...

By factoring the grammar. This is essential for writing a predictive parser in the next section because it removes any need for backtracking:

::

  MatchingParenthesis = <OpenParentheses> (<CloseParentheses> | MatchingParenthesis <CloseParentheses>)

Using the epsilon rule:

::

  MatchingParenthesis = <OpenParentheses> (MatchingParenthesis | e) <CloseParentheses>

Or using the ? operator (the most convenient to visualize, also easy to implement):

::

  MatchingParenthesis = <OpenParentheses> MatchingParenthesis? <CloseParentheses>

- Multiple grammars represent the same language
- A mathematical set of all possible ordered token strings

Derivations and Parse Trees
---------------------------
- A parse tree visually shows how we take input text and apply the productions to it
- When parsing any grammar we must have a starting *non-terminal* (the first one)
- Lets take a look at a very simple grammar

::

  List = <Identifier> <Comma> List
       | <Identifier>

Using the above grammar with the starting *non-terminal* of List, we will parse the following text into a parse tree:

::

  foo, bar, baz

- When we're parsing we have to look at which rules can possibly match, and if one fails we try the next rule
- Starting with the first rule we see that ``foo`` is an identifier, and we find the following ``,``
- Because that rule recursively uses the List *non-terminal* then we must start again at ``bar``
- The tokens ``bar`` and ``,`` match the first rule again, so we again recursively enter List
- Finally we reach ``baz``, but no ``,`` follows, so we must try another rule (*production*)
- The token ``baz`` fits the second rule, and as a base case we ended the recursion
- Why didn't we just choose the second rule when parsing ``foo``?
- Because we are greedy! Our parsing should want to parse as much as possible (think about reading a book)
- Technically the order of the rules should not matter, so long as the grammar is not *ambiguous*

We can represent the above logic in a more concisely with the following *derivation*. A *derivation* starts with a rule and expands each *non-terminal* with another rule. We backup and try another rule if the rule we are currently trying fails. The last line of a *derivation* always ends in *terminals* or tokens. We use *EBNF* style when performing derivations because its more concise.

::

  List => Identifier "," List             // Starting rule
       => "foo" "," List                  // Expand Identifier and Comma
       => "foo" "," Identifier "," List   // Expand List (first rule)
       => "foo" "," "bar" "," List        // Expand Identifier and Comma
       => "foo" "," "bar" "," Identifier  // Expand List (first rule fails, use second rule)
       => "foo" "," "bar" "," "baz"       // Expand 

The parse tree for the above List grammar and input text would look like:

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=rectangle, margin=0.1, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    List0 -> Identifier0;
    Identifier0 -> foo0;
    List0 -> comma0;
    List0 -> List1;
    
    List1 -> Identifier1;
    Identifier1 -> bar0;
    List1 -> comma1;
    List1 -> List2;
    
    List2 -> Identifier2;
    Identifier2 -> baz0;
    
    List0 [label="List"];
    Identifier0 [label="Identifier"];
    foo0 [label="foo"];
    comma0 [label=","];
    List1 [label="List"];
    Identifier1 [label="Identifier"];
    bar0 [label="bar"];
    comma1 [label=","];
    List2 [label="List"];
    Identifier2 [label="Identifier"];
    baz0 [label="baz"];
  }

- Every parent node is a *non-terminal* such as List and Identifier
- Every leaf node is a *terminal* or token, such as: ``foo``  ``bar``  ``,``
- The first *non-terminal* that we start with is the root of the tree
- Every time we read a token / *terminal* then we draw a leaf node with a connecting edge from the parent *non-terminal*
- Every time we enter a *non-terminal* then we draw a node with a connecting edge from the parent *non-terminal*
- If we find out that the *production* failed to parse, we need to backup (and erase the parts of the tree we just created)

To avoid having to think about which production we need to choose, or being greedy, we can refactor this grammar again using the *distributive* property:

::

  List = <Identifier> (<Comma> List)?

Lets try another more in depth example:

::

  Statement  = <If> <OpenParentheses> Expression <CloseParentheses> <OpenCurley> Statement <CloseCurley>
             | <Var> <Identifier> <Assignment> Expression <Semicolon>
  Expression = <True> | <False>

Parse the following text with the above grammar, and derive a parse tree from it:

::

  if (true)
  {
    if (false)
    {
      var zombie = true;
    }
  }

- We start with the ``Statement`` *non-terminal*
- We start matching the ``if`` rule token by token
- The ``if`` rule refers to the ``Expression`` *non-terminal*, so we walk down that
- We find ``true``, which completes the ``Expression`` *non-terminal*
- Continue parsing until we reach the ``var`` base case

The derivation would be (using EBNF style to shorten it):

::

  Statement => "if" "(" Expression ")" "{" Statement "}"
            => "if" "(" "true" ")" "{" Statement }
            => "if" "(" "true" ")" "{" "if" "(" Expression ")" "{" Statement "}" "}"
            => "if" "(" "true" ")" "{" "if" "( "false" ")" "{" Statement "}" "}"
            => "if" "(" "true" ")" "{" "if" "( "false" ")" "{" "var" "zombie" "=" Expression ";" "}" "}"
            => "if" "(" "true" ")" "{" "if" "( "false" ")" "{" "var" "zombie" "=" "true" ";" "}" "}"

The parse tree for this input text and this grammar will be:

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=rectangle, margin=0.1, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    Statement0 -> if0;
    Statement0 -> openParen0;
    Statement0 -> Expression0;
    Expression0 -> true0;
    Statement0 -> closeParen0;
    Statement0 -> openCurley0;
    Statement0 -> Statement1;
    
    Statement1 -> if1;
    Statement1 -> openParen1;
    Statement1 -> Expression1;
    Expression1 -> false1;
    Statement1 -> closeParen1;
    Statement1 -> openCurley1;
    Statement1 -> Statement2;
    
    Statement2 -> var2;
    Statement2 -> zombie2;
    Statement2 -> assign2;
    Statement2 -> Expression2;
    Expression2 -> true2;
    Statement2 -> endStatement2;
    
    Statement1 -> closeCurley1;
    Statement0 -> closeCurley0;
    
    Statement0 [label="Statement"];
    if0 [label="if"];
    openParen0 [label="("];
    Expression0 [label="Expression"];
    true0 [label="true"];
    closeParen0 [label=")"];
    openCurley0 [label="{"];
    Statement1 [label="Statement"];
    if1 [label="if"];
    openParen1 [label="("];
    Expression1 [label="Expression"];
    false1 [label="false"];
    closeParen1 [label=")"];
    openCurley1 [label="{"];
    Statement2 [label="Statement"];
    var2 [label="var"];
    zombie2 [label="zombie"];
    assign2 [label="="];
    Expression2 [label="Expression"];
    true2 [label="true"];
    endStatement2 [label=";"];
    closeCurley1 [label="}"];
    closeCurley0 [label="}"];
  }

Ambiguity
---------
- A grammar is ambiguous if there are multiple parse trees that exist for a single input
- Ambiguity is generally a sign that something will go wrong in parsing your language
- In the following example the Integer token is a sequence of digits from the tokenizer (literal)

::

  Expression = Expression <Minus> Expression
             | <Integer>

Derive a parse tree from the following input:

::

  8 - 6 - 1

- We could parse this input with (8 - 6) first or with (6 - 1) first.
- The correct version is (8 - 6) based on our knowledge of arithmetic
- Our grammar is ambiguous and allows for both definitions
- The *leftmost* derivation is where we expand left *non-terminals* first
- The *rightmost* derivation is where we expand right *non-terminals* first

The *leftmost* derivation is the (8 - 6) derivation:

::

  Expression  => Expression "-" Expression                    // Starting rule
              => (Expression "-" Expression) "-" Expression   // Expand the LEFMOST Expression
              => (Integer "-" Expression) "-" Expression      // Expand the LEFMOST Expression
              => ("8" "-" Expression) "-" Expression          // Expand Integer
              => ("8" "-" Integer) "-" Expression             // Expand the LEFMOST Expression
              => ("8" "-" "6") "-" Expression                 // Expand Integer
              => ("8" "-" "6") "-" Integer                    // Expand the LEFMOST Expression
              => ("8" "-" "6") "-" "1"                        // Expand Integer


- We use parentheses to make it clear which *non-terminal* we are expanding
- Is ``Expression "-" Expression`` to ``Expression "-" Expression "-" Expression`` left or right? (parentheses help!)

And the *leftmost* parse tree:

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=rectangle, margin=0.1, width=0.35, height=0.35];
    edge [fontsize=10, fontname=Verdana];

    Expression0 -> Expression1;
    Expression1 -> Integer0;
    Integer0 -> 8;
    Expression1 -> minus0;
    Expression1 -> Integer1;
    Integer1 -> 6;
    
    Expression0 -> minus1;
    Expression0 -> Expression2;
    Expression2 -> Integer2;
    Integer2 -> 1;
    
    Expression0 [label="Expression"];
    Expression1 [label="Expression"];
    Integer0 [label="Integer"];
    minus0 [label="-"];
    Integer1 [label="Integer"];
    minus1 [label="-"];
    Expression2 [label="Expression"];
    Integer2 [label="Integer"];
  }

The *rightmost* derivation is the (6 - 1) derivation:

::

  Expression  => Expression "-" Expression                    // Starting rule
              => Expression "-" (Expression "-" Expression)   // Expand the RIGHTMOST Expression
              => Expression "-" (Expression "-" Integer)      // Expand the RIGHTMOST Expression
              => Expression "-" (Expression "-" "1")          // Expand Integer
              => Expression "-" (Integer "-" "1")             // Expand the RIGHTMOST Expression
              => Expression "-" ("6" "-" "1")                 // Expand Integer
              => Integer "-" ("6" "-" "1")                    // Expand the RIGHTMOST Expression
              => "8" "-" ("6" "-" "1")                        // Expand Integer

And the *rightmost* parse tree:

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=rectangle, margin=0.1, width=0.35, height=0.35];
    edge [fontsize=10, fontname=Verdana];

    Expression0 -> Expression1;
    Expression1 -> Integer2;
    Integer2 -> 8;
    Expression0 -> minus1;
    Expression0 -> Expression2;
    
    Expression2 -> Integer0;
    Integer0 -> 6;
    Expression2 -> minus0;
    Expression2 -> Integer1;
    Integer1 -> 1;
    
    Expression0 [label="Expression"];
    Expression1 [label="Expression"];
    Integer0 [label="Integer"];
    minus0 [label="-"];
    Integer1 [label="Integer"];
    minus1 [label="-"];
    Expression2 [label="Expression"];
    Integer2 [label="Integer"];
  }

- These two parse trees are very similar to an *expression tree*
- An *expression tree* is a sub-tree of the *Abstract Syntax Tree*
- An expression tree is evaluated from bottom to top
- Leafs must be values or literals
- Parents must be binary or unary operators
- The *leftmost* derivation gives ``(8 - 6) - 1 => 1`` (correct)
- The *rightmost* derivation gives ``8 - (6 - 1) => 3`` (incorrect)

.. note:: Exercise: Trace the path of evaluation around the *expression tree*

Another classic case for ambiguity comes with single line if statements (without scope). Given the grammar:

::

  Statement   = "if" "(" Expression ")" Statement "else" Statement
              | "if" "(" Expression ")" Statement
              | "var" Identifier "=" Expression ";"
  Expression  = "true" | "false"

The following code actually has two derivations. This is the *leftmost* derivation:

::

  if (true)
    if (false)
      var zombie = true;
    else
      var headcrab = false;

The *rightmost* derivation we can represent simply through manipulation of whitespace (very confusing to new programmers!):

::

  if (true)
    if (false)
      var zombie = true;
  else
    var headcrab = false;

.. warning::

  Even if an ambiguity can be resolved in a grammar, it may still confuse a user of your language. Keywords at the beginning of different types of statements is a good way to let the user know unambiguously what is happening.

Classic Examples of Ambiguity
`````````````````````````````
In C it is legal to declare/extern a function within the definition of another function (extern is optional). You could write:

.. code-block:: cpp

  void MyFunction()
  {
    int OtherFunction(float);
  }

C++ added the ability to invoke constructors of variables defined on the stack.

.. code-block:: cpp

  void MyFunction()
  {
    MyType StackVariable(argument);
  }

Without looking to see whether ``argument`` is a type or a local variable, there is no way to know if this is a extern function declaration or a stack variable. This is especially problematic in this case:

.. code-block:: cpp

  void MyFunction()
  {
    something Something();
  }

C++ has no way of knowing in this case, so the behaviour is defined to always be an extern declaration. Technically this is ok because you don't need to manually invoke the default constructor, but as mentioned before, this can be **confusing** to new users of the language. It is best to design your language without these ambiguities.

Another example in C++:

.. code-block:: cpp

  auto collider = Collider<Sphere>(true);

Even advanced users of C++ will most likely look at this line and see a template instantiation of type ``Collider`` where the template type is ``Sphere``, passing ``true`` to the constructor.

.. code-block:: cpp

  bool Collider = true;
  bool Sphere = true;

Surprise! The operators < and > exist for bool types. The ``(true)`` is just an expression wrapped in grouping parentheses.

Elimination of Ambiguity
------------------------
- We can treat the if-else case similar to how we treated the order of edges in the DFA
- When we implement the if-else grammar, just be sure to always use the *leftmost* derivation
- In other words always pair the else with the closest if
- There is no general algorithm for doing this: the details depend upon your language design
- For the ``Expression "-" Expression`` we can apply associativity rules to make it unambiguous

Left Recursion
--------------
- Any grammar that has a recursive *non-terminal* on the left side of a production is considered *left recursive*
- A good example of left recursion:

::

  List  = List "," Identifier
        | Identifier

- The style of parser we'll be using later is known as a *recursive descent* parser
- Rules like this would literally translate into function calls:

.. code-block:: cpp

  void List()
  {
    List();
    Accept(",");
    // ...
  }

- The primary issue we have here is that List immediately recurses into itself
- An infinite recursion that will blow the stack

In general, we can take any *left recursive* rule written in the form of:

::

  A = A x | B

- ``A`` is a *non-terminal*
- ``x`` and ``B`` are can be *terminals* or *non-terminals* but they must not start with ``A``
- Think about what can be parsed with this grammar
- Either just ``B`` alone, or we could start with ``A x`` and recurse into ``A`` again
- This leads to ``Bxxxxx...``
- What's another way we could refactor this same grammar to be 

::

  A = B R | B
  R = x R | x

- Notice how this same grammar produces either just ``B`` or ``Bxxxxx...``
- We could also use the special *epsilon* rule (empty token)
- This rule is often denoted as either ``""`` in EBNF or in many grammars as a the epsilon symbol |epsilon|

::

  A = B R
  R = x R | ""

- The *epsilon* can always be eliminated from a grammar
- In the *recursive descent* implementation, the *epsilon* requires special handling
- Using the first refactor (without *epsilon*) we can rewrite the List grammar as:

::

  List    = Identifier ListEnd
          | Identifier
  ListEnd = "," Identifier ListEnd
          | "," Identifier

Recommended reading:

  - Section 2.2 of *Compilers: Principles, Techniques, and Tools* describes grammars in more detail
  - Section 4.3 of *Compilers: Principles, Techniques, and Tools* describes elimination of ambiguity, left recursion, and left factoring