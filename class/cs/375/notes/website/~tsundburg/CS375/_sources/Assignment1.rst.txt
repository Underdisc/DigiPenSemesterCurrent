
.. Merge with previous assignment 1 notes
.. Lots of little details, such as the newlines being included in the comments
.. Mention the submission server

Assignment 1
============
`Download The Assignment <../CS375Assignments/Assignment1.zip>`_

The goal of the first assignment is to create a tokenizer using a Deterministic Finite Automata.

- All of the code must be implemented within ``User1.cpp`` inside the ``UserCode`` directory

- The reference executable (sample driver) is provided in the ``Reference`` folder

  - Run a particular test by passing in a number to the command line
  - No arguments means run all tests

- The score you get for the assignment is the number of passed tests out of the total number of tests
- It is up to you to run *diff* or any similar differencing tool to verify that your code matches the reference executable

- Requires Visual Studio 2015

- The Visual Studio .sln is located within the ``CompilerClassAssignment1`` directory
  
- Please read all the comments above each of the driver functions that you must implement

- Submit your assignment using the online server at: :ref:`assignment-submission`

Implementation
--------------

The assignment is split into two parts. The first part involves implementing your own state and edge structures as well as the traversal algorithm for reading tokens from a string. The driver will request your code to create state machines for different languages and test them against sample input strings. The output of each test will be diffed, and any mismatch will cause you to fail that test:

- You must implement the following functions for Part 1:

  - ``AddState``, ``AddEdge``, ``AddDefaultEdge``, ``ReadToken``, ``DeleteStateAndChildren``

- The driver will be calling these functions to generate different token DFAs
- You must create and implement the DfaState class (forward declared by driver)

The second part of the assignment is for you to hook up your own states and edges to tokenize a language.

- You must implement the following functions for Part 2:

  - ``ReadLanguageToken``, ``CreateLanguageDfa``

- You must create your own DFA that can parse the following token types (regular expressions shown for reference):

- ``Whitespace = [ \r\n\t]+``

  - One or more space, carriage return, newline, or tab character

- ``Identifier = [a-zA-Z_][a-zA-Z0-9_]*``

  - A letter or underscore followed by any number of letters, numbers, or underscores

- ``IntegerLiteral = [0-9]+``

  - One or more digits

- ``FloatLiteral = [0-9]+[.][0-9]+(e[+-]?[0-9]+)?f?``

  - One or more digits, followed by a ``.``, followed by one or more digits, followed by an optional(``e`` with another optional(``+`` or ``-``) followed by one or more digits) and lastly an optional ``f``
  - Generally ``+`` is implied if ``+`` or ``-`` are not specified
  - The entire ``e`` part is optional
  - Note that FloatLiteral shares states with the IntegerLiteral
  - The above ``.`` character must be either placed in brackets ``[.]`` or escaped ``\.`` because it has special meaning in regular expressions (it means any character)

- ``StringLiteral = "([^"\\]|\\[nrt"])*"``

  - A quote ``"`` followed by a sequence of (any character that is not a ``\`` or ``"``) or (``\`` followed by any of the characters ``nrt"``) and lastly finished with a quote ``"``
  - Use the default edge here to accept any character (see the DFA notes)

- ``CharacterLiteral = '[^'\\]|\\[nrt']'``

  - A single quote ``'`` followed by (any character that is not a ``\`` or ``'``) or (``\`` followed by any of the characters ``nrt'``) and lastly finished with a single quote ``'``
  - Use the default edge here to accept any character (see the DFA notes)

- ``SingleLineComment = //.*(\r|\n|\0)``

  - Two forward slashes ``//`` followed by any sequence of characters, ending with either ``\r`` or ``\n`` or the eof ``\0``

- ``MultiLineComment``

  - A forward slash and star ``/*`` followed by any sequence of characters and ending with a ``*/``
  - Note that * can occur in the middle of a multi-line comment

- Keywords may be parsed as identifiers, and then later looked up using a unordered_map/map or other associative container
- All keywords are listed in *TokenKeywords.inl*
- Operators and symbols must be parsed using the DFA (see *TokenSymbols.inl*)
- The provided *inl* files can be processed using any text editor
- Alternately, each token is wrapped with a TOKEN() macro, which can be defined by you
- You can use the following trick macro/include trick:

.. code-block:: cpp

  const char* keywords[] =
  {
    // The TOKEN macro is used like TOKEN(Class, "class")
    #define TOKEN(Name, Value) Value,
    #include "../Drivers/TokenKeywords.inl"
    #undef TOKEN
    ""
  };
