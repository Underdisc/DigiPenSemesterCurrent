Modern Languages
================
- Many languages have added on features since C and C++
- Many of these features often simplify code, sometimes at the expensive of performance
- The following features are shared by languages such as C#, D, Lua, Python, Javascript and many others

Return Type Inference
---------------------
- A function does not have to declare its return type because it can be inferred by the ``return`` statements
- Must walk through all ``return`` statements to determine the type

Trivial case:

.. code-block:: as

  // Maybe in your language leaving the return type off means infer it
  function Foo()
  {
    return 5;
  }

- The compiler looks at the only return statement
- Determines the ``LiteralNode`` with value 5 to be of type ``Integer``
- Infers the the return type of ``Foo`` must be ``Integer``

A more complex case:

.. code-block:: as

  function GetHealth()
  {
    if (this.Dead)
      return 0;
    else
      return 100.0f;
  }

- Two return statements that return different types ``Integer`` and ``Float``
- Typically allowable to promote ``Integer`` to a ``Float`` (implicit cast)
- Return type inferred is ``Float``
- How did we determine which one to promote to? What if they were reversed?
- We need a *non order dependent operation*
- This is known as a **CommonType** operation

Examples:

- ``CommonType(Integer, Integer) => Integer``
- ``CommonType(Float, Integer) => Float``
- ``CommonType(Integer, Integer, Integer, Float) => Float``
- ``CommonType(Short, Long) => Long``
- ``CommonType(Null, Animal) => Animal``
- ``CommonType(Dog, Cat) => Animal``
- ``CommonType(Cat, Dog) => Animal``

An interesting fact of CommonType:

::

  CommonType(A, B) == CommonType(B, A)
  CommonType(A, CommonType(B, C)) == CommonType(A, B, C)

- In C this was originally exposed in the form of the ``ternary ?`` operator
- ``sizeof(condition ? 5 : 5.0)`` results in ``sizeof(double)``
- C++ generalized the concept, and exposed it to template meta-programming / type-traits

.. code-block:: as

  function FactoryCreate(typeName : String)
  {
    if (typeName == "Dog")
      return new Dog();
    else if (typeName == "Cat")
      return new Cat();
    else
      return new Gazelle();
  }

Decltype
--------
- Seems like a complex operation
- In reality it is just a step back from the ``sizeof`` operator
- Computes the type of an expression without evaluating the value
- Must have symbols resolved up to that point

.. code-block:: as

  var lives : Integer = 5;
  var health : decltype(lives) = 100;

- Simply run the semantic analysis phase on the ``ExpressionNode`` contained as a child of the ``DecltypeNode``
- ``DecltypeNode`` could substitute anywhere for a ``TypeReferenceNode`` aka ``TypeNode``
- The above ``decltype`` would:

  - Evaluate the ``NameReference`` for ``lives``
  - Lookup the ``Variable`` symbol for ``lives``
  - Retrieve type ``Integer``
  - ``health`` becomes of type ``Integer``

- It avoids running the code by simply not visiting the children of ``DecltypeNode`` in code generation or even an interpreter

.. warning:: Compilers are easy. Sorry for ruining all the magic.

- The ``sizeof(lives)`` would do the exact same thing except it would ask the ``Integer`` symbol for its platform dependent size

.. code-block:: as

  // What about these?
  decltype(3 + 9.0);
  sizeof(3 + 9.0);

Delegates
---------
- A function pointer paired with a ``this`` it should be called on
- Facilitates OOP design and abstraction
- Generalizes callbacks for static and instance functions
- Consider a regular C++ function pointer

.. code-block:: cpp

  typedef void (*DamageCallback)(float health);

- Easy to pass around, store, and invoke
- Useful for custom virtual behavior (callbacks, state machines, etc)

.. code-block:: cpp

  void OnPlayerDamaged(float health)
  {
    //...
  }
  
  //...
  DamageCallback callback = &OnPlayerDamaged;

- Close cousin to delegates was C++ *member function pointers*

.. code-block:: cpp

  void Player::OnDamaged(float health)
  {
    //...
  }
  
  // Error!
  DamageCallback callback = &Player::OnDamaged;

- We cannot store our Player's ``OnDamaged`` member function because the signature does not match
- The implicit ``this`` we often forget about

.. code-block:: cpp

  // Psuedo code, if we had the explicit this
  void Player::OnDamaged(Player* this, float health)

  // Would have to redeclare DamageCallback (Player:: denotes the implicit this)
  typedef void (Player::*DamageCallback)(float health);
  
  // Success
  DamageCallback callback = &Player::OnDamaged;
  
  // Calling and passing the implicit this parameter looks like this
  (player->*callback)(100.0f);

- Now we cannot accept the original OnPlayerDamaged callback!
- Also cannot accept methods defined on other types, e.g. ``Animal::OnDamage``
- **Delegates** abstract away the implicit ``this``
- It does so by storing the 'this' along with a wrapped function pointer

.. code-block:: cpp

  class DamageDelegate
  {
  public:
    void* mThis;
    
    // This version cannot accept either the static or the instance...
    typedef void (*DamageCallback)(void* thisPointer, float health);
    DamageCallback mFunction;
  };

- For a static function:

  - ``mThis`` would typically be null
  - ``mFunction`` is a compiler generated wrapper that simply calls the static version and discards ``thisPointer``

.. code-block:: cpp

  // The original user code (global / static function)
  void OnPlayerDamaged(float health)
  {
    //...
  }
  
  // The compiler generated wrapper that it can stuff into a delegate
  void OnPlayerDamaged_STATIC_WRAPPER(void* thisPointer, float health)
  {
    // The compiler doesn't even need to use
    // 'thisPointer' because its calling a static
    return OnPlayerDamaged(health);
  }
  
- For an instance version, the compiler automatically generates a static version that can call the instance version

.. code-block:: cpp

  // The original user code (instance function)
  void Player::OnDamaged(float health)
  {
    //...
  }
  
  // The compiler generated wrapper that it can stuff into a delegate
  void OnPlayerDamaged_INSTANCE_WRAPPER(void* thisPointer, float health)
  {
    // The compiler only ever stores the wrapper function pointer
    // and the 'this' pointer at the same time into a DamageDelegate
    // Therefore it is safe to cast 'thisPointer'
    Player* player = reinterpret_cast<Player*>(thisPointer);
    
    // Now invoke the member function
    return player->OnDamaged(health);
    
    // Alternatively via ->*
    return (player->*&Player::OnDamaged)(health);
  }

- Notice that in order to create an instance delegate, **we must have an object instance**
- Writing ``this.ApplyDamage`` is typically another way of creating a delegate
- Writing ``this.ApplyDamage()`` is just calling a created delegate (typically optimized to a direct call)

A compiler that supports delegates can perform the following operations

.. code-block:: as

  var callback = player.OnDamaged;

Equivalently in C++:

.. code-block:: cpp

  DamageDelegate callback;
  callback.mThis = player;
  callback.mFunction = &OnPlayerDamaged_INSTANCE_WRAPPER;

And the static version:

.. code-block:: as

  var callback = OnPlayerDamaged;

Equivalently in C++:

.. code-block:: cpp

  DamageDelegate callback;
  callback.mThis = nullptr;
  callback.mFunction = &OnPlayerDamaged_STATIC_WRAPPER;

- In languages like C# there is no syntax for writing static or instance function pointers, **only delegates**

.. code-block:: cpp

  // This is similar to C++'s typedef
  delegate void DamageDelegate(float health);
  
Closures & Anonymous Functions
------------------------------
- Anonymous function simply means unnamed function, also known as a *lambda*
- Typically refers to nested functions
- Compiler may allow nested function to access stack locals within the parent function
- Unsafe to call anywhere but in that function scope due to direct pointers to the stack
- A **closure** is a function that is allowed to capture variables
- C++ recently introduced this feature, but other languages have taken it much further

.. code-block:: cpp

  void Update()
  {
    int lives = 10;
    
    auto applyDamage = [&lives](float amount) -> bool
    {
      if (amount > 100.0f)
        --lives;
      return true;
    };
    
    applyDamage(150.0f);
    
    printf("%d\n", lives);
  }

- The compiler is able to generate a new class on the fly for the closure
- This is approximately equivalent to:

.. code-block:: cpp
  
  class ApplyDamageClosure
  {
  public:
    int* lives;
    
    bool Run()
    {
      if (amount > 100.0f)
        --(*lives);
      return true;
    }
  };

  void Update()
  {
    int lives = 10;
    
    ApplyDamageClosure applyDamage;
    applyDamage.lives = &lives;
    
    applyDamage.Run(150.0f);
    
    printf("%d\n", lives);
  }

- What about capturing by value?
- Instead of ``int* lives`` it just becomes ``int lives``
- C# allows you to safely return closures that refer to stack variables by reference
- Instead of copying a pointer into a generated class, it promotes all refernces to the local variable to being part of the class


- The equivalent code in C#:

.. code-block:: cpp

  void Update()
  {
    int lives = 10;
    
    Func<float, bool> applyDamage = (amount) =>
    {
      if (amount > 100.0f)
        --lives;
      return true;
    };
    
    applyDamage(150.0f);
    
    Console.WriteLine(lives);
  }

- Really just becomes:

.. code-block:: cpp
  
  class ApplyDamageClosure
  {
    public int lives;
    
    public bool Run()
    {
      if (amount > 100.0f)
        --lives;
      return true;
    }
  }

  void Update()
  {
    // Notice that 'lives' the local variable no longer exists
    // The closure is the first thing to be allocated here
    var applyDamage = new ApplyDamageClosure();
    applyDamage.lives = 10;
    
    applyDamage.Run(150.0f);
    
    Console.WriteLine(applyDamage.lives);
  }

- What about multiple closures in the same function?
- All of them lift variables into a single generated class (shared)
- This is where garbage collection becomes nice

.. note:: I would recommend for your own languages to allow the users to explicitly declare captures. C# always captures by reference, and this has lead to many accidental bugs.

.. code-block:: cpp
  
  void Update()
  {
    // Create a list of closures
    var applyDamageList = new List<Action>();
    
    foreach (var player in PlayerList)
    {
      // Create a closure that 
      doDamageList.Add(() => --player.Lives);
    }
    
    // Now apply damage to each player... except this only ever hurts the last player
    // This is not a bug, but confuses many
    foreach (var applyDamage in applyDamageList)
    {
      applyDamage();
    }
  }

Properties
----------
- Programmers observed the pattern of writing ``GetPosition`` and ``SetPosition`` as an abstraction of interface
- Some implementations need to perform critical tasks internally (update broad-phase)
- Often boiler plate code that only serves to decrease performance and provides no notable abstraction
- Desire for a consistent interface e.g. all functions
- Properties make get and set functions appear as if they were regular data members

The following is a snippet from C#:

.. code-block:: cpp

  int Lives = 9;
  
  // This is a property (to the user it almost appears entirely like a data member)
  float Health
  {
    get
    {
      return 100.0f;
    }
    set
    {
      if (value < 0.0f)
        --this.Lives;
    }
  }

Using the data member and property elsewhere

.. code-block:: cpp
  
  player.Lives = 8;
  Console.WriteLine(player.Health);
  player.Health = -50;
  Console.WriteLine(player.Lives);
  player.Health += 1000;

In reality the code is:

.. code-block:: cpp
  
  player.Lives = 8;
  Console.WriteLine(player.GetHealth());
  player.SetHealth(-50);
  Console.WriteLine(player.Lives);
  // The compiler would not evaluate the 'player' expression twice
  player.SetHealth(player.GetHealth() + 1000);

- Properties can typically also be virtual (they are just functions)
- Typically a way to actually get function pointers or delegates to the getter or setter
- Unlike a data member, there is no way to get an address of a property

Extension Functions & Properties
--------------------------------
- One of my personal favorite features
- The ability to add a function or property to a class that is not your own
- Does not break encapsulation because attached method can still only access public members

The following code is a snippet from C#:

.. code-block:: cpp

  class Cat
  {
    public void DoDamage(float amount) { /* ... */ }
    public void LightOnFire() { /* ... */ }
  }
  
  static class CatExtensions
  {
    // This will be treated as an instance function on Cat
    static void Explode(this Cat cat)
    {
      bob.DoDamage(10000.0f);
      bob.LightOnFire();
      Console.WriteLine("BOOM!");
    }
  }
  
  //...
  var bob = new Cat();
  bob.Explode();

- C# cannot extend static functions on other types due to syntax limitations
- C# does not support extension properties (properties are just functions)
- Why did they not just use ``this`` inside the extension?

Pure Functions
--------------
- A function without side effects
- No access to global or external variables
- Return value is only determined by parameter inputs
- Typically a concept of functional programming
- Imperative languages typically allow local variable only side effects
- Pure can be enforced by the compiler similar to const

.. note:: Pure functions have the awesome property that they are deterministic. For the same set of inputs, you will always get the same output.

- Pure functions can be *memoized* by caching the result (missing **r** is intentional)

  - Only used if the function call is more expensive than the caching mechanism
  - May be evaluated by a heuristic and compile time

- Examples include ``cos``, ``sin``, ``ceil``, ``atan2``, etc

.. note:: A pure function whose inputs are all compile time literals **can be evaluated at compile time**.

- Hence newer C++ features such as ``constexpr``

Mixins
------
- First appearance was D
- Language must treat string literals as compile time constants
- Pure functions can both accept and return string literals
- Perform concatenation and operations at compile time
- Mixin statement evaluates a string literal as if it was code

.. code-block:: as

  var lives = 9;
  mixin("var health = 100;");
  Print(lives);
  Print(health);

- The above is a trivial example that does not seem very useful
- Power comes from being able to define compile time functions that return strings

.. code-block:: as

  // In our own psudeo language
  pure function EarlyOut(name : String)
  {
    return "if (" + name + " == null) return;";
  }
  
  //...
  var player = game.FindObject("Player");
  mixin(EarlyOut("player"));

- Somewhat of a replacement for macros

  - Typically only usable within statements or a scope block
  - Cannot be used to emit ``{`` or ``}``

- A slightly more complex example:

.. code-block:: as

  pure function ComponentsAsLocals(gameObject : String)
  {
    return
      "var transform = " + gameObject + ".GetTransform();" +
      "var body      = " + gameObject + ".GetRigidBody();" +
      "var space     = " + gameObject + ".GetSpace();";
  }
  
  //...
  var player = game.FindObject("Player");S
  mixin(ComponentsAsLocals("player"));
  body.Velocity += Vec3(0, 1, 0);

