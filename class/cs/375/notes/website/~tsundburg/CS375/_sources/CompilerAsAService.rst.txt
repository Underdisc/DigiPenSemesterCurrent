Compiler As A Service (IDE)
===========================
- Long standing train of thought that the IDE or text editor is separate from the language
- Modern times are blurring the lines
- Compiler treated as a library rather than a black box
- Known as **compiler as a service**
- Compiler may also be open-sourced
- Exposes the tokenizer, AST, type system, on the fly compilation, etc.
- May include features that enhance IDE capabilities
- Works well with *error recovery*

.. note::

  In the following lecture I use the ``?`` symbol to denote where the cursor is in typical IDE functionality

Minimal Rebuild
---------------
- The traditional view of a compiler takes all inputs and produces an output program
- In languages like C/C++ compilation units are separable allowing for individual compilation
- Modification of an inclusion (header file) results in a rebuilding of all dependent units
- Trivial build systems will build all files required always
- In a module based language, it becomes more complicated because files are not separable
- Language should provide support to query which parts of a program need rebuilding
- Build a dependency map (which symbols depend on which other symbols)
- Can run less expensive phases first, such as parser to build AST
- Hash AST nodes and compare them to previous build AST nodes
- Must store AST nodes either in memory or within a file format
- Pre-compiled header files in C/C++ are saved AST nodes
- IDE may let the language know which files or ranges of text were modified
- Can be important for performance of the following IDE features
- Must be **very careful** to avoid incorrect assumptions / improper dependency maps
- Results in build artefacts, regular occurrence in MSVC 2010

::

  > I regularly run into issues where “Build all” forgets to update a
  > precompiled header/dependency leaving me with a broken binary

  We hit this problem semi-regularly. It’s a bug in the updating of the .tlog files that hold dependencies. I wrote a script that scans for bogus .tlog files and blows them away when detected. We run this on all of our build machines. I discussed this with Microsoft a lot and I’m hopeful that it’s fixed for VS 2013. We’ll see.
  
  - Bruce Dawson

Member Auto Complete
--------------------
- Querying members on an expression via the ``.`` or ``->`` operators
- Must resolve the type of an expression first
- Automatically done by running *Semantic Analysis* over the AST
- May need to re-parse the entire context surrounding the member access (function, class, etc.)
- For efficiency, works best with a minimal-rebuild system
- Let the *Semantic Analysis* phase know that we're querying a member access token
- Callback upon type resolution of the left operand of ``MemberAccessNode``
- Enumerate members of the left hand type
- Needs to work with tolerant mode (most likely the right of the ``.`` is invalid)

.. code-block:: as

  function Test()
  {
    // We need the surrounding context of an expression
    // to pick up local variables, functions, globals, etc.
    // Could also use previous built library or minimal rebuild
    var a : Animal;
    
    // We would query the expression at the '.'
    // 'a' is a NameReferenceNode that resolves to the Variable symbol above
    // The left of '.' becomes expression type 'Animal'
    // Enumerate members of 'Animal' for the IDE
    a.?
    
    // Another example, where we have a complex expression being executed
    // The binary operator '*' would resolve into a type of Vector3
    // The '.' would result in enumerating all the members of Vector3
    var x = (Vector3(1, 2, 3) * 5.0f).?
  }

Call Tips / Overloads
---------------------
- Similar to member auto complete
- Pass in the cursor position into *Semantic Analysis* for the ``(`` token
- When the left hand side completes its type checking we perform a callback
- If language supports overloads, we want to enumerate all possible overloads by name
- Unless calling a function pointer (single function)
- Advanced features include partial overload choosing based on parsed parameters

.. code-block:: as

  class Player
  {
    function Attack(damage : Integer, target : Entity);
    function Attack(damage : Integer, name : String);
    function Attack(name : String);
  }
  
  function Test(player : Player)
  {
    // We would query the expression at the '('
    // 'player.Attack' results in a multiple function symbols
    // This would show the list of possible overload choices
    player.Attack(?
    
    // A more advanced feature includes narrowing overload choices
    // The IDE also typically highlights parameters, shows comments, etc.
    player.Attack(5, ?
  }

Local / Expression Completion
-----------------------------
- Suggest local variables and members that would complete an expression
- Could expect a list of types to follow a particular expression
- Often coupled with **local word completion**

  - Tokens that are parsed from the language can be provided to the IDE for automatic completion
  - Can also suggest built in keywords or tokens depending on context, e.g. ``this``

.. code-block:: as

  var lives : Integer;
  var health : Integer;
  var height : Float;

  // Here the possible suggestions could include 'lives' and 'health'
  // Typically with these features they offer all suggestions, even 'height'
  // however the incompatible options are sorted lower
  // This is because the user could choose 'height' and then cast it
  var x : Integer = ?

  // Combining the feature of expression completion with member access, the IDE
  // would prefer to show members that are compatible with Integer
  var x : Integer = this.?

- Must consider types that can be implicitly converted the same
- Binary operators also consider all possible operators between left and right types
- Overload parameters can also suggest local variables (list of types)

Cursor Hovering
---------------
- When the cursor in an IDE hovers above a type, variable, expression
- If the type is an expression, we often want to show the ``Type`` of that expression
- May also want to show information about a member symbol
- Useful to the user to show comments that appear above the symbol
- Uses the *Symbol Querying* algorithm defined below

.. code-block:: as
  
  // Our game dynamically composes lyrics based on the player's karma
  var lyrics = "Hello darkness";
  
  // When hovering over lyrics, we would want to show that it is a variable symbol
  // We'd also want to show that its resolved expression type is String
  // The user typically also appreciates showing comments for the variable
  lyrics? += " my old friend";
  
Go To Definition
----------------
- Jump to the location in code where a symbol's name is defined
- For a type, this is the file that defines the class
- For a member, we want to jump to the nested variable or function
- Local variable name references should jump to the local variable definition
- Uses the *Symbol Querying* algorithm defined below
- In some cases, the definition of the class **may not exist**

  - When loading the types from a library
  - When binding a class from an external source (C++ scripting integration)

- Still useful to generate a language view of the class
- What would it look like **without definitions** if it were coded in language
- Walk through the type and member symbols generating a class view

  - Relies heavily on reflection - in C# this is called "from metadata"
  - May allow user to customize formatting
  - May cache generation of class view
  - Often preserves original comments above symbols

.. code-block:: as
  
  class Player
  {
    // Go-to-definition on the below expression should bring us here
    var Lives : Integer;
  }
  
  function Test()
  {
    // Attempting 'go-to-definition' on Lives scans the AST
    // The cursor is inside:
    //   FunctionNode(Test)
    //   VariableNode(x)
    //   MemberAccessNode(Lives)
    var x = this.Liv?es;
  }

Symbol Querying
---------------
- Helper function that resolves a symbols and nodes given a cursor position
- Returns 3 main pieces of information:

  - Most Leaf Node
  - Definition Symbol (Type / Variable / Function / Label)
  - Expression Type

- Leaf node allows the user to walk up all the parent nodes (chain)

  - Not technically always a leaf, such as a MemberAccessNode
  - We want the 'closest to leaf' node where the cursor falls within the range

- Definition symbol enables *go-to-definition* behavior
- AST nodes are given a character range
- Start of the first token that produced the node to the end of the last token that finalized the node
- Note: *An AST node's range often completely contains another AST node*
- Symbols store a location where they were originally defined (often the name token)
- Query for a leaf node given the position of a cursor/caret

  - Walk through nodes until you find that your cursor is within one of them
  - Descend down its children and repeat until we reach a leaf node
  - Can use binary search because ranges are monotonic and siblings should not overlap

- Each node type will have its own behavior for resolving a symbol
- Many nodes result in no symbols being resolved
- **Very tolerant** because *Tokenizer*, *Parser*, or *Semantic Analysis* could have failed
- Nicer to use ``ErrorType`` symbol than ``null``, see *Error Recovery*

TypeNode
````````
- Resolves a ``Type`` symbol during the *Semantic Analysis* phase
- If the type is a pointer, dereference it until we get to the actual type
- e.g. *Pointer* -> *Pointer* -> **Animal**
- This becomes the *definition* symbol

VariableNode
````````````
- Note: *Not the same as a NameReferenceNode; this is the **declaration***
- If the variable uses **type-inference**, it is desirable to emulate the behavior of ``TypeNode``
- The implicit ``Type`` becomes the *definition* symbol
- Otherwise the ``Variable`` symbol itself becomes the *definition* symbol

.. note::

  In C#, only the ``var`` keyword results in the implicit ``Type`` becoming the *definition*, otherwise the name of the variable refers to its own ``Variable`` symbol.

NameReferenceNode
`````````````````
- Resolves a symbol during the *Semantic Analysis* phase
- Could be a ``Variable``, ``Function``, or even ``Type`` symbol
- The resolved symbol becomes the *definition* symbol

MemberAccessNode
````````````````
- Resolves a member symbol of another ``Type`` during the *Semantic Analysis* phase
- Directly return the resolved member symbol
- If the language supports ``overloading`` this may return a list of possible ``Function`` symbols
- If a ``CallNode`` or ``CastNode`` node parent resolved the overload to a single function we may return that ``Function`` symbol
- Both cases used for the *definition* symbol

CallNode
````````
- Only occurs on attempting to query the ``()``
- If the left operand is a member, redirect to ``MemberAccessNode`` behavior
- Otherwise we cannot resolve *definition* symbol at compile time

ClassNode/FunctionNode
``````````````````````
- Their own created symbols become their *definition* symbols

ExpressionNode
``````````````
- Use the ``Type`` resolved by *Semantic Analysis*
- Output as the *expression type*
- No *definition* symbol

Comments
--------
- Often stripped or ignored in the parsing phase
- Useful information for the user
- Sometimes difficult to determine which node a comment was intended for
- Can mostly assume that it is attached to the next node that begins after it
- Unless comment is entirely contained within a function

.. code-block:: as

  function Test1()
  {
    // How many lives the player has
    var lives : Integer;
    
    var health : /* always use int! */ Integer;
    
    // This is NOT a comment for Test2
  }
  
  function Test2()
  {
  }

- When extracting comments before the parser, we can scan over the AST

  - Find the *next* node to attach the comment to
  - Every node has a container of comment tokens
  - Often comments are normalized/trimmed (remove ``//`` and spaces)

- No real **correct** solution, just **useful** solutions

Refactor Rename
---------------
- Must correctly find all references to a symbol (member, type, function)
- Easily done by scanning the entire AST after *Semantic Analysis*
- Find any reference to symbol that is being renamed
- Unsafe to perform if there are errors / recovery performed on the AST

  - Even VAX shows the list of changes to the user before performing

- User may start on the actual defining symbol
- May also want to use *go-to-definition* / *Symbol Querying* functionality

.. code-block:: as

  class Player
  {
    // Right click renaming Lives
    var Lives : Integer;
  }
  
Versus:

.. code-block:: as

  // Right click renaming Lives
  var x = this.Lives;

Debuggers
---------
- When a debugger allows the user to hover the cursor over a variable
- Need to properly resolve symbols within the language and map back to stack locals
- Many debuggers can inspect members of an object (also requires symbol lookup)
- Debugger contains map of AST nodes / symbols to temporaries

.. code-block:: as

    1) var bytes = ("hello " + "world").Length?;
  > 2) totalBytes += bytes;

Formatting
----------
- Automatically arranging the user's code based on a set of rules
- Used in many popular IDEs (C# with Visual Studio, eclipse with Java)
- Provide stylistic options to the user (spacing, newlines, alignment, etc.)
- Can perform this using custom regex rules (find operators with no spacing, too much spacing)
- Can also manually count scopes and perform indents
- Another form is to implement a Visitor for your AST

  - Emits the same language code as you walk the AST
  - Must be careful with respect to 'syntactic sugar' or other modifications of the tree
  - Must preserve comment locations (and sometime multiple lines specified by the user)
  - More options than regex (``:`` for a type vs ``:`` for a initializer list)

Statement Evaluation
--------------------
- Parse the base 'statement' rule of our grammar / parser
- Do not run the root rules (Block in our case)
- Conveniently returns a pointer to a ``StatementNode``
- Statement evaluators often detect if a statement is an ``ExpressionNode`` (dynamic cast)
- Generate code for the single statement and execute it
- Semantic analysis may require a statement be placed within a function or class

.. code-block:: as

  Math.Sin(5)

Behind the scenes the compiler may implicitly place this statement into a function. The generated function must match return type:

.. code-block:: as

  function ExecuteStatement() : Real
  {
    return Math.Sin(5)
  }

Or if your compiler supports dynamic features such as a variant or any:

.. code-block:: as

  function ExecuteStatement() : Variant
  {
    return Math.Sin(5)
  }

- Expressions typically print out their resulting value after execution
- Useful for a **game console**
- Most dynamic languages implicitly support this functionality

  - Often a *file* / *chunk* / *block* is a script itself

Read Eval Print Loop
--------------------
- Similar to statement evaluation, but does not require completed statements
- Parser must be re-entrant

  - When the parser runs out of input, it waits for more
  - Classic recursive descent does not work well with re-entrant
  - Can use co-routines or cooperative multi-threading (fibers)

- Typically can cancel writing a statement
- Often you can also  define whole functions or classes
- Static language requires separate operating rules because its assumed that evaluation will happen as soon as possible
- Does not generate a single library in the same way we expect a full compilation to

Typing the following:

.. code-block:: as

  var Lives : Integer = 9;

Creates a fully usable global variable and evaluates the initial value expression:

.. code-block:: as

  ++Lives;

.. note::

  Some languages like C# don't even allow declaring a variable without being inside a class, meaning REPL for C# must be a *special case*:

Other Features
--------------
- Compiler as a service allows for many other features to be implemented
- Auto Correct
- Visual Macro Expansion
- Translators
- Linters
