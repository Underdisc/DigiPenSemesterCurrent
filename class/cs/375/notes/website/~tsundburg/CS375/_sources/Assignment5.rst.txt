Assignment 5
============
`Download The Assignment <../CS375Assignments/Assignment5.zip>`_

The goal of the fifth assignment is to execute our program by running *Interpreter* over the AST.

- All of the code must be implemented within ``User5.cpp`` inside the ``UserCode`` directory
- Extra headers (.h/.hpp) can be submitted to the grading server
- This assignment requires ``User1.cpp``, ``User3.cpp``, and ``User4.cpp`` from the previous assignments

- The reference executable (sample driver) is provided in the ``Reference`` folder

  - Run a particular test by passing in a number to the command line
  - No arguments means run all tests

- The score you get for the assignment is the number of passed tests out of the total number of tests
- It is up to you to run *diff* or any similar differencing tool to verify that your code matches the reference executable

- Requires Visual Studio 2015

- The Visual Studio .sln is located within the ``CompilerClassAssignment5`` directory
  
- Please read all the comments above each of the driver functions that you must implement

- Submit your assignment using the online server at: :ref:`assignment-submission`

Implementation
--------------
- You will be performing **2 passes** over the AST
- Implement the following functions within ``Driver5.hpp`` in your ``User5.cpp`` (*read comments*):

  - ``InterpreterPrePass`` runs the pre-pass we describe below
  - ``CreateInterpreter`` / ``DestroyInterpreter`` allocates your Interpreter class (probably a Visitor)
  - ``InterpreterFunctionCall`` is responsible for walking FunctionNodes
  - ``AddSinFunction`` registers a custom ``Sin`` function (must match the ``mCallback`` signature)

.. warning:: Some changes have been made to Assignment 4, listed here:

  - class Library changed member named mAllSymbols to mOwnedSymbols
  - SemanticAnalyize no longer takes multiple libraries (dependencies)
  - All core types are added to the Library we are currently building for simplicity
  - Added BytePointerType for ease of use
  - This means that globals IntegerType, BooleanType, etc change between tests
  
    - This could be bad if you cached them with static variables
  
  - NameReferenceNode now has an mSymbol that must be filled out in the SemanticAnalyize phase
  
    - At the same place mResolvedType is set (4th pass)

Pass 1 (Pre-Pass)
-----------------
- A Variant class that can store Integer, Float, Byte, Boolean, Pointer, and Function is provided 
- Visit LiteralNodes and pre-compute the Variant into LiteralNode->mValue
- Variant's mType must be set to the types defined the Driver4.hpp and Driver5.hpp

  - IntegerLiteral - IntegerType
  - FloatLiteral - FloatType
  - CharacterLiteral - ByteType
  - StringLiteral - BytePointerType
  - True - BooleanType
  - False - BooleanType

- Use atoi and atof for string to Integer/Float conversion
- For string and character literals, you must strip quotes and escape the following with the proper ascii values: **nrt\\'"**
- The char* should be placed within the Variant's mPointer
- If needed, LiteralNode has a member mString where you may store the allocated memory
- Also visit FunctionNode to setup essentials for our interpreter making function calls

  - Set the node->mSymbol->mCallback to InterpreterFunctionCall
  - Set the node->mSymbol->mFunctionNode to the node we are currently visiting

- Be sure to use ``VisitResult::Continue`` when visiting the FunctionNode, because we want to get all literals inside of it

InterpreterFunctionCall
-----------------------
- Create local variables (map of Variable* to Variants) by pushing to the locals stack
- Walk the ``function->mFunctionNode->mParameters``

  - Each ParameterNode has the ``Variable* mSymbol``
  - Map ``mSymbol`` in the new locals to the corresponding input parameter from ``parameters``
  - Walk the function node on our Function symbol
  - Catch the exception you throw from your ReturnNode (see below)

- **Be sure to pop the locals from the stack, otherwise you will never properly return!**

Pass 2 (Interpretation)
-----------------------
- Since we are generally explicitly handling all nodes, remember to use ``VisitResult::Stop``
- On your Interpreter, you need to store local variables and global variables

  - Locals should be stored per function call in a stack or similar data structure
  - Typically pushed and popped within your InterpreterFunctionCall
  - We'll be accessing locals and gloabls via a NameReferenceNode
  - Map the Variable* symbol to the Variant for both locals and globals so it can be looked up in NameReferenceNode

VariableNode
````````````
- Compute the initial value if there is one
- Store the initial value within our current stack frame's local variables
- Do not handle global variable initialization

ReturnNode
``````````
- If a return value is present, walk it to set mResult
- Must throw your own return exception (to be caught within InterpreterFunctionCall)
- This will unroll the tree recursion and effectively return from the function
- Do not handle implicit returns within functions

IfNode
``````
- Evaluate the condition if it exists (could be an ``else`` block with no condition)
- If true, walk the statements within the scope node
- If false, walk the mElse if there is one
- Do not handle pointer types for the condition (only Boolean)

WhileNode
`````````
- Loop while the condition is true, and walk the statements within the scope node

CastNode
````````
- Must be able to cast between all types Integer, Float, Boolean, Byte (12 cases)
- Casting from our own type to our own type does nothing (let mResult pass through)
- Do not handle pointer types

LiteralNode
```````````
- Output the value we pre-computed in the pre-pass

NameReferenceNode
`````````````````
- ``mSymbol`` in the semantic pass points to a Variable or Function
- If it is a Function, set the resulting variant to the resolved type and set the mFunctionNode
- If it is a Variable, use the variable symbol to look up the Variant from the locals or globals

  - If the Variant doesn't exist, create one in the locals or globals map
  
    - Variant default constructor Zeroes out)
    - Be sure to set the mType!
    
  - **In most languages, variables are LValues or references**
  - For simplicity, our Variant is going to contain both the value of the variable and a pointer back to the Variant value
  - This allows the assignment operator to write to the variable
  - ``mResult.mPointerToValue = &value.mValue;``

- Hint: Use ``dynamic_cast`` to discover if it is a Variable or Function

  - It will be fast since Symbol has a shallow inheritance hierarchy

BinaryOperatorNode
``````````````````
- Only handle ``=`` assignment for Integer, Float, Byte, Boolean

  - To write to the variable, write to the ``mPointerToValue`` (see ``NameReferenceNode``)
  - Example: *(float*)lhs.mPointerToValue = rhs.mValue.mFloat;

- Operators ``+ - * / %`` for Integer, Float, Byte

  - Always result in the same type
  - ``%`` for Float should use ``fmod`` in ``<math.h>``

- Operators ``< > <= >= == !=`` for Integer, Float, Byte

  - Always result in Boolean

- Operators ``&& ||`` only between Boolean and Boolean

  - Must implement short circuit evaluation (don't Walk the right node!)

- Do not handle pointer operations or NullType comparisons
- Do not handle operators between Class types
- Do not handle chain assignment or compound assignment operators

CallNode
````````
- Evaluate all the parameters and get all the Variants into an std::vector
- Evaluate the left hand side to get the function Variant (mFunction should be set)

  - We confirmed that we can only call Functions in Semantic Analysis!

- Invoke the ``mCallback`` member and pass everything in to call the function

  - The callback will be implemented by you for your own functions compiled within the languages
  - For Test 1, the first callback is one that the driver provides

- **Do not call ``InterpreterFunctionCall`` explicitly here!**

AddSinFunction
--------------
- Made to familiarize you with how script binding typically works within a game engine
- Create a ``Sin`` function via ``CreateFunction``, ``GetFunctionType``
- The input should be a single Float and the output is also a Float
- Set the mCallback to your own callback

  - Signature: ``Variant Sin(Interpreter* interpreter, Function* function, std::vector<Variant>& arguments)``
  - Get the input from the Variant, and return the result as a Variant (be sure to set mType)
  - Actually call the ``<math.h>`` ``sin`` function

- Once completed, the language will be able to actually call the math sin function!

Unhandled Nodes
---------------
- For the simplicity of the assignment, there are many nodes and cases you do NOT need to handle
- Typically only the most derived nodes will have behavior (no behavior for ExpressionNode)
- The following nodes do not need an implemented visitor and will not be tested:

  - UnaryOperatorNode
  - MemberAccessNode
  - IndexNode
  - BreakNode
  - ContinueNode
  - GotoNode
  - LabelNode
  - ForNode

.. note:: Feel free to add as much functionality to the compiler on your own time! Pointer dereferencing, class layouts, member access, etc.
