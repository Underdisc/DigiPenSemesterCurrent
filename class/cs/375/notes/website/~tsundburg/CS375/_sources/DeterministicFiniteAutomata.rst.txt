.. Pseudo code for a state/edge structure
.. Formal theory on LL(1) vs LL(k) and backtracking, also DFA/NFA
.. DFAs for Comments, white-space, string
.. FIX PSEUDO CODE AT THE BOTTOM (IMPROPER ERROR AND NO LOOP, SHOULD BACKTRACK)
.. To extend the lecture, we could talk about graph-viz output (part of the assignment)
.. Also we could talk about automatically outputting the hard-coded stuff
.. Mention the state virtual edges or character ranges

Deterministic Finite Automata (DFA)
===================================
- A DFA is a form of state machine (directed graph)
- A state machine has *edges* and *states*
- States may have data attached to them
- Outgoing edges have a condition which we may traverse if the condition is met
- Deterministic means it is unambiguous where no outgoing edges share the same condition
- For tokenization, our edge conditions are single characters ('a', 'b', etc)
- An *accepting state* is a special state that tells us a token is completely parsed (greedy parsing may let us go further)
- A rectangle is the *starting state*
- A double octagon is an *accepting state* (note: other literature typically uses a double-circle)
- The names of the states let us identify them and may also specify extra information

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=octagon, margin=0, width=0.35, height=0.35];
    edge [fontsize=10, fontname=Verdana];

    s0 -> s1 [label=" t "];
    s1 -> s2 [label=" h "];
    s2 -> s3 [label=" i "];
    s3 -> s4 [label=" s "];
    s2 -> s5 [label=" a "];
    s5 -> s6 [label=" t "];
    
    s0 [shape=rectangle, margin=0.1];
    s4 [shape=doubleoctagon];
    s6 [shape=doubleoctagon];
  }

- What words can this state machine parse?
- Start at state **s0**, the starting state
- The only outgoing edge is on ``t``, so we know our word must start with ``t``
- Move to **s1**
- The only outgoing edge is on ``h``, so we know our word must start with ``th``
- Move to **s2**
- We now have two options, our word can either start with ``thi`` or ``tha``
- If we move down to **s3** from **s2**, we can see the only edge is on ``s``, bringing us to **s4**
- **s4** is an accepting state, so the entire word would be ``this``
- If we move down to **s5** from **s2**, we can see the only edge is on ``t``, bringing us to **s6**
- **s6** is an accepting state, so the entire word would be ``that``
- Think of the DFA as a mathematical set, the set is all the possible strings it could parse
- The set of this DFA is {``this``, ``that``}
- Often a DFA will produce an infinite set when we introduce cycles (numbers, identifiers, etc)

Traversal Algorithm
-------------------
1. Start at the *starting state* (rectangle) and save the beginning of our token
2. Read a character and check outgoing edges from the *current state* to see if any characters match
3. If an edge matches, follow the edge to the new state, that is now our *current state*
4. If it is an *accepting state* (double octagon), store it and the current position as the *last accepted position*
5. Repeat step 2
6. If no edges match, the *last accepted position* is the end of our token (if none, it's an **error**)

- Repeat this algorithm multiple times until the input stream is consumed (``EOF`` or ``\0``) or an error occurs

.. note:: Exercise: Write a DFA that accepts ``foo`` or ``foobar``

Backtracking and Lookahead
--------------------------
- The maximum amount of characters between one *accepting state* and another is called *lookahead*
- We may need to read *lookahead* characters before we accept a new token, or backup to the *last accepted position*
- No backtracking is required if an error occurs (no accepting state was hit)
- ``LA(K)`` describes a language that requires K amount of *lookahead*
- A tokenizer is said to be ``LA(1)`` if it only requires a single character of look-ahead
- Very simple serialization formats are generally ``LA(1)``
- ``LA(*)`` is used to denote an arbitrary amount of *lookahead*

LA(1) Examples
``````````````
- A grammar with tokens ``class``, ``function``, ``{``, ``}``
- A grammar with tokens ``<``, ``>``, ``<=``, ``>=``

LA(2) Examples
``````````````
- A grammar with tokens ``=``, ``===``
- A grammar that allows ``3``, ``3.14159``, ``3.ToString()`` with a classic number, identifier, and member access ``.`` token

LA(*) Examples
``````````````
- A token that must start and end with ``a`` and can have any number of ``a`` and ``b`` in between
- Consider ``abbbbbabbabbbbbbb``: the token is actually just ``abbbbbabba`` but we have to keep reading ``b`` to see if another ``a`` follows

Lookahead Implementation
------------------------
- We need to be able to read ahead in a stream (whether it be from a file, over a network, etc)
- Very efficient tokenizers will discard old data and buffer up to the K amount needed (ring buffer)
- For simplicity, we'll assume the entire string is in contiguous memory, allowing for ``LA(*)``
- Any attempt to read beyond the string should return ``\0`` (acts as a sentinel)

Parsing Integers
----------------
- An integer literal is typically a string of consecutive numbers
- Possibly followed by a letter denoting the storage size
- This is just a common convention, your language could use tally marks ||| to mean 3
- Depending on the language, starting with 0 may mean *octal*, 0x may mean *hex*, etc
- Valid digits for a number include 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
- A DFA that could parse a single digit would look like:

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=doubleoctagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s0 [label=" 0 "];
    root -> s1 [label=" 1 "];
    root -> s2 [label=" 2 "];
    root -> s3 [label=" 3 "];
    root -> s4 [label=" 4 "];
    root -> s5 [label=" 5 "];
    root -> s6 [label=" 6 "];
    root -> s7 [label=" 7 "];
    root -> s8 [label=" 8 "];
    root -> s9 [label=" 9 "];
    
    root [shape=rectangle];
  }

- All edges point at an accepting state
- Notice all accepting states have no differences between each other
- No difference in outgoing edges
- They can be merged into one state

.. graphviz::

  digraph
  {
    nodesep=0.2;
    ranksep=1.0;
    node [fontsize=10, fontname=Verdana, shape=doubleoctagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> end [label=" 0 "];
    root -> end [label=" 1 "];
    root -> end [label=" 2 "];
    root -> end [label=" 3 "];
    root -> end [label=" 4 "];
    root -> end [label=" 5 "];
    root -> end [label=" 6 "];
    root -> end [label=" 7 "];
    root -> end [label=" 8 "];
    root -> end [label=" 9 "];
    
    root [shape=rectangle];
  }

- More easily expressed using a shorthand for the ASCII range [0-9]

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=doubleoctagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s0 [label=" [0-9] "];
    root [shape=rectangle, width=0.4];
  }

- What about a DFA that could parse two digits?

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=octagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s0 [label=" [0-9] "];
    s0 -> s1 [label=" [0-9] "];
    
    s1 [shape=doubleoctagon];
    root [shape=rectangle];
  }

- What about a DFA that could parse one **OR** two digits?
- The union of the set of all single digit numbers and the set of all two digit numbers
- In formal language theory, this is known as *alternation*

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=doubleoctagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s0 [label=" [0-9] "];
    s0 -> s1 [label=" [0-9] "];
    
    root [shape=rectangle];
  }

- Both have become accepting states, therefore we can parse one or two
- Remember that even though we hit an accepting state early, we keep going because we're **greedy**
- Obviously we could keep adding states to parse a fixed number of digits
- What about parsing any number of digits?
- We can introduce cycles in the DFA (edges that point back to states we've already traversed)

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=doubleoctagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s0 [label=" [0-9] "];
    s0 -> s0 [label=" [0-9] "];
    
    root [shape=rectangle];
  }

- Accepts as many digits as possibly until it runs into a non-digit character
- Why didn't we just loop back to the root?
- The root is **shared** between all DFAs in your tokenizer
- Lets write a DFA that can parse ``hi`` or any number (the DFA above)

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=octagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s0 [label=" [0-9] "];
    s0 -> s0 [label=" [0-9] "];
    root -> s1 [label=" h "];
    s1 -> s2 [label=" i "];
    
    root [shape=rectangle];
    s0 [shape=doubleoctagon];
    s2 [shape=doubleoctagon];
  }

- Looping back to the root would allow for strings like ``42hi``, not what we want
- Lets make it parse storage specifiers (integer-suffix) ``u``/``U``, ``l``/``L``
- We'll also append information to the accepting states to denote what type of literal it is

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=doubleoctagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s0 [label=" [0-9] "];
    s0 -> s0 [label=" [0-9] "];
    s0 -> s1 [label=" [uU] "];
    s1 -> s2 [label=" [lL] "];
    s0 -> s3 [label=" [lL] "];
    s3 -> s4 [label=" [uU] "];
    
    root [shape=rectangle];
    s0 [label="int"];
    s1 [label="unsigned int"];
    s2 [label="unsigned long"];
    s3 [label="long"];
    s4 [label="unsigned long"];
  }

- Lots of accepting states (often when we have optional suffixes)

Parsing Floats
--------------
- A string of digits, a decimal, another string of digits, with optional exponential form
- May have a trailing ``f`` to specify a 32 bit float
- Some languages may allow ``3.``, ``3.f`` or even ``.3``
- We'll keep ours simple and require numbers on both sides

.. graphviz::

  digraph
  {
    nodesep=0.2;
    ranksep=0.0;
    node [fontsize=10, fontname=Verdana, shape=octagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s0 [label=" [0-9] "];
    s0 -> s0 [label=" [0-9] "];
    s0 -> s1 [label=" . "];
    s1 -> s2 [label=" [0-9] "];
    s2 -> s2 [label=" [0-9] "];
    s2 -> s3 [label=" f "];
    
    root [shape=rectangle];
    s2 [shape=doubleoctagon, label="double"];
    s3 [shape=doubleoctagon, label="float"];
  }

- What about exponential form?
- An optional suffix of ``e`` with an optional ``+`` or ``-`` and a sequence of digits
- We must consider that after the exponential form, we could still parse an ``f``

.. graphviz::

  digraph
  {
    nodesep=0.2;
    ranksep=0.0;
    node [fontsize=10, fontname=Verdana, shape=octagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s0 [label=" [0-9] "];
    s0 -> s0 [label=" [0-9] "];
    s0 -> s1 [label=" . "];
    s1 -> s2 [label=" [0-9] "];
    s2 -> s2 [label=" [0-9] "];
    s2 -> s3 [label=" f "];
    s2 -> s4 [label=" e "];
    s4 -> s5 [label=" [+-] "];
    s5 -> s6 [label=" [0-9] "];
    s6 -> s6 [label=" [0-9] "];
    s4 -> s6 [label=" [0-9] "];
    s6 -> s3 [label=" f "];
    
    root [shape=rectangle];
    s2 [shape=doubleoctagon, label="double"];
    s3 [shape=doubleoctagon, label="float"];
    s6 [shape=doubleoctagon, label="double"];
  }

.. note:: Exercise: Write a DFA for C standard float/double literals*

Parsing Keywords
----------------
- Keywords always create a chain of states
- Each connecting edge is the next character from the keyword
- Lets try the keyword ``extern``

.. graphviz::

  digraph
  {
    nodesep=0.0;
    ranksep=0.0;
    node  [fontsize=10, fontname=Verdana, shape=octagon, margin=0, width=0.35, height=0.35, label=""];
    edge  [fontsize=10, fontname=Verdana];

    root -> s0 [label=" e "];
    s0 -> s1   [label=" x "];
    s1 -> s2   [label=" t "];
    s2 -> s3   [label=" e "];
    s3 -> s4   [label=" r "];
    s4 -> s5   [label=" n "];
    
    root [shape=rectangle];
    s5 [shape=doubleoctagon, label="extern"];
  }

- Simple, now lets union in the DFA for ``explicit``

.. graphviz::

  digraph
  {
    nodesep=0.2;
    ranksep=0.0;
    node [fontsize=10, fontname=Verdana, shape=octagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s00 [label=" e "];
    s00  -> s01 [label=" x "];
    s01  -> s02 [label=" t "];
    s02  -> s03 [label=" e "];
    s03  -> s04 [label=" r "];
    s04  -> s05 [label=" n "];
    s01  -> s06 [label=" p "];
    s06  -> s07 [label=" l "];
    s07  -> s08 [label=" i "];
    s08  -> s09 [label=" c "];
    s09  -> s10 [label=" i "];
    s10  -> s11 [label=" t "];
    
    root [shape=rectangle];
    s05 [shape=doubleoctagon, label="extern"];
    s11 [shape=doubleoctagon, label="explicit"];
  }

Parsing Identifiers
-------------------
- Typically a string of letters, numbers, and underscores ``[a-zA-Z_0-9]``
- Must start with a letter or underscore ``[a-zA-Z_]``

.. graphviz::

  digraph
  {
    node [fontsize=10, fontname=Verdana, shape=octagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s0 [label=" [a-zA-Z_] "];
    s0 -> s0 [label=" [a-zA-Z_0-9] "];
    
    root [shape=rectangle];
    s0 [shape=doubleoctagon, label="identifier"];
  }

- What if the identifier could start with a number?
- Remember, the root state is **shared**
- Numbers and identifiers that start with numbers would have the same outgoing edge starting from the root
- This would be a **non-deterministic**
- What about keywords?

.. graphviz::

  digraph
  {
    nodesep=0.2;
    ranksep=0.0;
    node [fontsize=10, fontname=Verdana, shape=octagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s0 [label=" [a-zA-Z_] ", color=red];
    s0 -> s0 [label=" [a-zA-Z_0-9] "];
    
    root -> s00 [label=" e ", color=red];
    s00  -> s01 [label=" x "];
    s01  -> s02 [label=" t "];
    s02  -> s03 [label=" e "];
    s03  -> s04 [label=" r "];
    s04  -> s05 [label=" n "];
    s01  -> s06 [label=" p "];
    s06  -> s07 [label=" l "];
    s07  -> s08 [label=" i "];
    s08  -> s09 [label=" c "];
    s09  -> s10 [label=" i "];
    s10  -> s11 [label=" t "];
    
    root [shape=rectangle];
    s05 [shape=doubleoctagon, label="extern"];
    s11 [shape=doubleoctagon, label="explicit"];
    
    root [shape=rectangle];
    s0 [shape=doubleoctagon, label="identifier"];
  }

- This is **NOT** a DFA, because two edges share the same condition on ``e``
- We could remove the starting ``e`` from the left identifier edge
- Tokens like ``exp`` are identifiers, but the resulting graph says they would not be
- In practice, our DFA can have duplicate edges, but we traverse them in container order
- Never backtrack to redo an edge with the same condition (that would be **non-deterministic**)

.. graphviz::

  digraph
  {
    nodesep=0.2;
    ranksep=0.0;
    node [fontsize=10, fontname=Verdana, shape=octagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s00 [label=" (0) e ", color=blue];
    s00  -> s01 [label=" x "];
    s01  -> s02 [label=" t "];
    s02  -> s03 [label=" e "];
    s03  -> s04 [label=" r "];
    s04  -> s05 [label=" n "];
    s01  -> s06 [label=" p "];
    s06  -> s07 [label=" l "];
    s07  -> s08 [label=" i "];
    s08  -> s09 [label=" c "];
    s09  -> s10 [label=" i "];
    s10  -> s11 [label=" t "];
    
    root -> s0 [label=" (1) [a-zA-Z_] ", color=blue];
    s0 -> s0 [label=" [a-zA-Z_0-9] "];
    
    root [shape=rectangle];
    
    s00 [shape=doubleoctagon, label="identifier"];
    s01 [shape=doubleoctagon, label="identifier"];
    s02 [shape=doubleoctagon, label="identifier"];
    s03 [shape=doubleoctagon, label="identifier"];
    s04 [shape=doubleoctagon, label="identifier"];
    s05 [shape=doubleoctagon, label="extern"];
    s06 [shape=doubleoctagon, label="identifier"];
    s07 [shape=doubleoctagon, label="identifier"];
    s08 [shape=doubleoctagon, label="identifier"];
    s09 [shape=doubleoctagon, label="identifier"];
    s10 [shape=doubleoctagon, label="identifier"];
    s11 [shape=doubleoctagon, label="explicit"];
    
    root [shape=rectangle];
    s0 [shape=doubleoctagon, label="identifier"];
  }

- This DFA still does not correctly parse identifiers
- What about parsing ``experience``?

  - Traverse the ``e`` edge
  - Traverse the ``x`` edge
  - Traverse the ``p`` edge
  - Fail to find any outgoing edges that matched ``e``
  - Accept ``exp`` as an identifier
- Technically every state in a keyword needs an edge back to the looping identifier state
- Get ready...

.. graphviz::

  digraph
  {
    nodesep=0.2;
    ranksep=0.0;
    node [fontsize=10, fontname=Verdana, shape=octagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s00 [label=" (0) e ", color=blue];
    s00  -> s01 [label=" (0) x ", color=blue];
    s01  -> s02 [label=" (0) t ", color=blue];
    s02  -> s03 [label=" (0) e ", color=blue];
    s03  -> s04 [label=" (0) r ", color=blue];
    s04  -> s05 [label=" (0) n ", color=blue];
    s01  -> s06 [label=" (0) p ", color=blue];
    s06  -> s07 [label=" (0) l ", color=blue];
    s07  -> s08 [label=" (0) i ", color=blue];
    s08  -> s09 [label=" (0) c ", color=blue];
    s09  -> s10 [label=" (0) i ", color=blue];
    s10  -> s11 [label=" (0) t ", color=blue];
    
    s00 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    s01 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    s02 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    s03 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    s04 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    s05 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    s06 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    s07 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    s08 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    s09 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    s10 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    s11 -> s0 [label=" (1) [a-zA-Z_0-9] ", color=blue];
    
    root -> s0 [label=" (1) [a-zA-Z_] ", color=blue];
    s0 -> s0 [label=" [a-zA-Z_0-9] "];
    
    root [shape=rectangle];
    
    s00 [shape=doubleoctagon, label="identifier"];
    s01 [shape=doubleoctagon, label="identifier"];
    s02 [shape=doubleoctagon, label="identifier"];
    s03 [shape=doubleoctagon, label="identifier"];
    s04 [shape=doubleoctagon, label="identifier"];
    s05 [shape=doubleoctagon, label="extern"];
    s06 [shape=doubleoctagon, label="identifier"];
    s07 [shape=doubleoctagon, label="identifier"];
    s08 [shape=doubleoctagon, label="identifier"];
    s09 [shape=doubleoctagon, label="identifier"];
    s10 [shape=doubleoctagon, label="identifier"];
    s11 [shape=doubleoctagon, label="explicit"];
    
    root [shape=rectangle];
    s0 [shape=doubleoctagon, label="identifier"];
  }

- Our own data structures for the State/Edge could have a way of sharing a single edge to reduce memory
- **In practice, we use simple identifier parsing and then look up if the identifier was actually a keyword via a hash-map**
  
.. note:: Exercise: Write a DFA for string literals with escape sequences

Parsing Operators
-----------------
- Operators get parsed the same way as keywords
- We don't need to worry about the *identifier* problem
- Parsing the operators ``<``, ``<=``, ``>``, ``>=``, ``=``, ``==``, ``+``, ``-``, ``->``

.. graphviz::

  digraph
  {
    nodesep=0.2;
    ranksep=0.0;
    node [fontsize=10, fontname=Verdana, shape=doubleoctagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s00 [label=" < "];
    s00  -> s01 [label=" = "];
    root -> s02 [label=" > "];
    s02  -> s03 [label=" = "];
    root -> s04 [label=" = "];
    s04  -> s05 [label=" = "];
    root -> s06 [label=" + "];
    root -> s07 [label=" - "];
    s07  -> s08 [label=" > "];
    
    root [shape=rectangle];
    s00 [label="less than"];
    s01 [label="less than or equal"];
    s02 [label="greater than"];
    s03 [label="greater than or equal"];
    s04 [label="assignment"];
    s05 [label="equality"];
    s06 [label="plus"];
    s07 [label="minus"];
    s08 [label="arrow"];
  }

.. note:: Exercise: Write a DFA for single/multi-line comments, and for whitespace

State Structure
---------------
- For the edges, we can use an associative container (a map, hash map, etc)
- We could alternatively also use an array with the character as inputs (256 values if ASCII)
- If there are very few edges, we might just want to actually create an edge structure and scan through all edges (may be faster)

.. code-block:: cpp

  enum TokenType
  {
    Invalid,
    
    FloatLiteral,
    IntegerLiteral,
    StringLiteral,
    
    Identifier,
    LessThan,
    GreaterThan,
    //...
  };

  class State
  {
  public:
    std::unordered_map<char, State*> mEdges;
    State* mDefaultEdge;
    
    // Any value other than 'Invalid' means this IS an accepting state
    TokenType mAcceptingToken;
  };

- This approach can be entirely data driven if ``TokenType`` is just an ``int`` where 0 means ``Invalid``
- The DFA could be read from a file or even provided by a driver ***hint hint***

Hard-coded DFA
--------------
- Its a good idea to represent your tokenization logic on paper as a DFA
- For more efficient tokenization, you can hard-code the state-machine into switch statements and a state variable
- Give every state an integer ID
- ``enum`` works well because you can name states when you see fit
- Store the beginning and current token positions, as well as the *last accepted position* and token

.. graphviz::

  digraph
  {
    nodesep=0.2;
    ranksep=0.0;
    node [fontsize=10, fontname=Verdana, shape=doubleoctagon, margin=0, width=0.35, height=0.35, label=""];
    edge [fontsize=10, fontname=Verdana];

    root -> s00 [label=" < "];
    s00  -> s01 [label=" = "];
    root -> s02 [label=" h "];
    s02  -> s03 [label=" i "];
    
    root [shape=rectangle];
    s00 [label="LessThan"];
    s01 [label="LessThanOrEqual"];
    s02 [label="S0", shape=octagon];
    s03 [label="Hi"];
  }

In C++:

.. code-block:: cpp

  enum TokenType
  {
    Invalid,
    LessThan,
    LessThanOrEqual,
    Hi
  };
  
  enum State
  {
    Start,
    LessThan,
    S0,
  };

  //...
  
  TokenType acceptedToken = TokenType::Invalid;
  State state = State::Start;
  
  while (true)
  {
    char c = ReadCharacter();
    switch (state)
    {
      case State::Start:
      {
        switch (c)
        {
          case '<':
          {
            state = State::LessThan;
            acceptedToken = TokenType::LessThan;
            break;
          }
            
          case 'h':
          {
            state = State::S0;
            break;
          }
          
          default:
          {
            BacktrackOrError();
            return;
          }
        }
        break;
      }
      
      case State::LessThan:
      {
        if (c == '=')
        {
          // We have no more edges, nothing left to parse (no need to be greedy!)
          acceptedToken = TokenType::LessThanOrEqual;
          return;
        }
        else
        {
          BacktrackOrError();
          return;
        }
        break;
      }
      
      case State::S0:
      {
        if (c == 'i')
        {
          acceptedToken = TokenType::Hi;
          return;
        }
        else
        {
          BacktrackOrError();
          return;
        }
        break;
      }
    }
  }

- Many tools exist (LEX, FLEX, ANTLR, etc) to take in a data definition and spit out hard-coded parsers (not all DFAs)