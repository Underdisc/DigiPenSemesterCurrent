
.. note:: Random Quote: Highways are like hash-tables, you really don't want them full

Recursive Descent Parsing
=========================
- The easiest form of parser to write
- From grammar directly to hand written code
- Starts from the beginning of the input and consumes tokens while *recognizing* rules
- Can be generated with tools
- Grammar must NOT include left-recursion (not to be confused with left-factoring)
- Recognition is the process of validating whether a language parses correctly or not
- First get your parser to 'recognize', then build an AST afterwards

Predictive Parser
-----------------
- Like the DFA tokenizer, a recursive descent parser should be deterministic
- Looks at a single token and should know the rule to follow based on that token
- Grammars need to be factored to avoid backtracking (no rules that start with the same terminals)

  - And by the same logic, no rules that start with the same non-terminals

- Predictive means the performance is linear
- Non-predictive with back-tracking can become polynomial in time
- Recursive descent can easily be adapted to support back-tracking, which can be useful

Guidelines
----------
- Every rule becomes the name of a function
- Accept is a function that peeks at the next token and compares it to the one passed in (returns true/false)
- Expect is the same as Accept, but terminates the entire parser usually with an exception
- We could use Accept everywhere we use Expect, but Expect can give the user better errors

Alternations
------------
- A recursive descent implementation for alternation (the or operator) would look like the following:

::

  Expression = <True> | <False>

.. code-block:: cpp

  bool Expression()
  {
    if (Accept(Token::True))
      return true;
    
    if (Accept(Token::False))
      return true;
    
    return false;
  }

- This can also be rewritten in the simpler form:

.. code-block:: cpp

  bool Expression()
  {
    return Accept(Token::True) || Accept(Token::False);
  }

- Alternation between more than one rule is also simple:

::

  Expression = Boolean | <Identifier>
  Boolean = <True> | <False>

.. code-block:: cpp

  bool Expression()
  {
    return Boolean() || Accept(Token::Identifier);
  }

  bool Boolean()
  {
    return Accept(Token::True) || Accept(Token::False);
  }

- In both of the above cases, the grammar was simple and entirely left factored
- Is the below grammar entirely left factored?

::

  Dangerous = Explosion | "boom" "kablewie"
  Explosion = "boom" | "kablamo"

- **No**, because two of the rules share the same left terminal/token
- Perform the substation of the ``Explosion`` rule into ``Dangerous``

Alternation and Concatenation
-----------------------------
- Concatenation translates directly to the and && operator
- Lets look at an example where the grammar is not left factored:

::

  Select = "select" "from" "table"
         | "select" "from" "row"

- Notice "select" and "from" appear in two alternatives of the ``Select`` rule
- This would require a look-ahead of 3
- Can be implemented with recursive descent, but not recommended:

.. code-block:: cpp

  bool Select()
  {
    size_t lastTokenPosition = this->TokenPosition;
    
    if (Accept("select") && Accept("from") && Accept("table"))
      return true;
    
    // We need to reset the token position here!
    this->TokenPosition = lastTokenPosition;
    
    if (Accept("select") && Accept("from") && Accept("row"))
      return true;
    
    return false;
  }

- Manually resetting the token position is tedious
- Can use a special stack object to roll the token position back on failure

.. code-block:: cpp

  struct StackSaver
  {
    size_t mLastTokenPosition;
    bool mAccepted;
    
    StackSaver(Parser* parser) :
      mLastTokenPosition(parser->TokenPosition),
      mAccepted(false)
    {
    }
    
    ~StackSaver()
    {
      if (mAccepted == false)
        parser->TokenPosition = mLastTokenPosition;
    }
  };

- In order to use StackSaver in this case we must either use separate scopes
- Or implement alternatives as separate functions (many prefer this):

.. code-block:: cpp

  bool Select()
  {
    return Select1() || Select2();
  }

  bool Select1()
  {
    StackSaver saver;
    if (Accept("select") && Accept("from") && Accept("table"))
    {
      saver.mAccepted = true;
      return true;
    }
    
    return false;
  }

  bool Select2()
  {
    StackSaver saver;
    if (Accept("select") && Accept("from") && Accept("row"))
    {
      saver.mAccepted = true;
      return true;
    }
    
    return false;
  }

- Technically the StackSaver is not needed in Select2, because we call it second
- Becomes difficult to know when its needed (any time there could be acceptable backtracking)
- Can add helper functions like ``bool StackSaver::Accept(bool input)`` to simplify code (returns the same input)
- Left factor your grammars and avoid all of this!
- What if the user was to attempt to parse the following:

::

  select with table

- At what point does the compiler know this was an error?
- Both ``Select1`` and ``Select2`` fail, therefore ``Select`` fails
- Compiler does not explain to the user why ``Select`` fails
- Lets take a look at a **left factored** version of the above grammar:

::

  Select = "select" "from" ("table" | "row")

.. code-block:: cpp

  bool Select()
  {
    return Accept("select") && Accept("from") && (Accept("table") || Accept("row"));
  }

- Much less code to parse left-factored grammars
- Compiler still does not explain to the user why ``Select`` fails
- If the grammar was entirely left factored, we know that after the ``select`` keyword we **expect** the ``from`` keyword
- Technically we can expect the ``select`` keyword too, but imagine there are other grammar rules

.. code-block:: cpp

  bool Select()
  {
    return Accept("select") && Expect("from") && Expect(Accept("table") || Accept("row"));
  }

- Now the compiler will fail on the exact token and will ideally report line and file numbers
- Two versions of the ``Expect`` function:

.. code-block:: cpp

  bool Expect(bool succeeded)
  {
    if (succeeded)
      return true;
    
    throw ParserException();
  }
  
  // Most likely this will actually take an enum, but for this example we take a string
  bool Expect(const char* token)
  {
    // Calls the above version of Expect
    return Expect(Accept(token));
  }

- We can also be really nice to the user and add error messages to our Expect function:

.. code-block:: cpp

  bool Select()
  {
    return
      Accept("select") &&
      Expect("from", "The 'from' keyword must follow the 'select' keyword") &&
      Expect(Accept("table") || Accept("row"), "You can only select from a 'table' or a 'row'");
  }

Recursion
---------

::

  Statement = If | Assignment
  Assignment = <Identifier> <Assignment> Expression <Semicolon>
  If = <If> <OpenParenthesis> Expression <CloseParenthesis> <OpenCurley> Statement <CloseCurley>
  Expression = <True> | <False>

- This grammar is entirely friendly to a recursive descent parser
- Statement is our starting rule
- Assignment is our base case for the recursion of the If statement
- No **left recursion**
- No **ambiguity**
- Every alternative can be predicted with a single non-terminal
- From Statement, there are two possible options, If and Assignment
- The first terminal token in If is literally "if"
- The first terminal token in Statement is an Identifier
- If we were to write this as a DFA, there would be two deterministic edges on "if" and Identifier
- The only other rule with alternation is Expression, which is also predictive on "true" and "false"

.. code-block:: cpp

  bool Expression()
  {
    return Accept(Token::True) || Accept(Token::False);
  }
  
  bool Assignment()
  {
    if (Accept(Token::Identifier) == false)
      return false;
    
    // At this point in time we can use Expect, because the grammar has been
    // entirely left-factored and we know there are no other options
    // Note: We also do not need to check the result of Expect because its either true, or throws!
    Expect(Token::Assignment);
    Expect(Expression());
    Expect(Token::StatementEnd);
    
    // We could simplify our code by just returning the last Expect call
    return true;
  }

  bool If()
  {
    // An if statement must start with "if" as per the grammar
    if (Accept(Token::If) == false)
      return false;
    
    // We know that there is only one valid form of If so we can use Expect instead of Accept
    Expect(Token::OpenParenthesis);
    Expect(Expression());
    Expect(Token::CloseParenthesis);
    Expect(Token::OpenCurley);
    Expect(Statements());
    return Expect(Token::CloseCurley);
  }

  bool Statement()
  {
    return If() || Assignment();
  }

- You generally can shorten the code using short-circuit evaluation

.. code-block:: cpp

  bool Expression()
  {
    return Accept(Token::True) || Accept(Token::False);
  }
  
  bool Assignment()
  {
    return
      Accept(Token::Identifier) &&
      Expect(Token::Assignment) &&
      Expression() &&
      Expect(Token::StatementEnd);
  }

  bool If()
  {
    return
      Accept(Token::If) &&
      Expect(Token::OpenParenthesis) &&
      Expression() &&
      Expect(Token::CloseParenthesis) &&
      Expect(Token::OpenCurley) &&
      Statements() &&
      Expect(Token::CloseCurley);
  }

  bool Statement()
  {
    return If() || Assignment();
  }

Alternation Empty Rule
----------------------

Optional Token
``````````````
- The following grammar has an optional construct:

::

  Start = "start" ("immediately"|) ";"

- This is the equivalent of using the regular expression ``?`` operator:

::

  Start = "start" "immediately"? ";"

- To implement this, we simply ``Accept`` the token ``task``, but ignore whether it returns true or false

.. code-block:: cpp

  bool Start()
  {
    if (Accept("start") == false)
      return false;
    
    Accept("immediately");
    
    return Expect(";");
  }

Optional Rule
`````````````
- The same technique works for an optional rule, again we just disregard the return value
- Note this will fail if the rule uses ``Expect``, however the first token is always parsed with ``Accept``
- The user expects this! *pun intended*

::

  Start = "start" Task? "immediately"? ";"
  Task = "server" | "dumb" "terminal"

.. code-block:: cpp

  bool Start()
  {
    if (Accept("start") == false)
      return false;
    
    Task();
    Accept("immediately");
    
    return Expect(";");
  }

  bool Task()
  {
    return
      Accept("server") ||
      Accept("dumb") && Expect("terminal", "Right now we only support starting a dumb terminal");
  }

- The following would all be valid lines of input:

::

  start;
  start server;
  start dumb terminal immediately;

- What if the user wrote:

::

  start dumb server immediately;

- The grammar specifies that the entire ``Task`` rule is optional, so why does this fail?
- Because ``dumb server`` is not a valid ``Task``
- Even if we backtracked, we'd still be stuck at the ``dumb`` token and would fail on ``Expect(";")``
- The user would have less information:

::

  start dumb server immediately;
        ^
        The compiler expected a ';' but instead got 'dumb'

- Instead of:

::

  start dumb server immediately;
             ^
             Right now we only support starting a dumb terminal

Optional Concatenation
``````````````````````
- In the following grammar, the two tokens ``dumb terminal`` are concatenated and are entirely optional:

::

  Start = "start" ("dumb" "terminal")? ";"

.. code-block:: cpp

  bool Start()
  {
    if (Accept("start") == false)
      return false;
      
    // The following is NOT valid, because it would allow just "dumb" or just "terminal"
    // Accept("dumb");
    // Accept("terminal");
    
    // We must use && to ensure they either both happen, neither
    // We still ignore the result of the entire expression
    // We could use Accept or Expect here, it depends on if we want the errors or not
    Accept("dumb") && Expect("terminal");
    
    return Expect(";");
  }

Kleene and Positive Closures
----------------------------
- The following grammar would allow for input such as ``call foo bar baz``
- We've left off the ``Identifier`` rule
- Remember, the *Kleene closure* \* means we can have *zero or more* of the previous

::

  Call = "call" Identifier*

.. code-block:: cpp

  bool Call()
  {
    if (Accept("call") == false)
      return false;
    
    // Because the * is similar to an optional, we don't let its return value
    // affect our return in this function
    while (Identifier());
    
    // If this was using our tokenizer, it would be similar to
    // while (Accept(TokenType::Identifier));
    
    return true;
  }

- If we were to use a *positive closure* + we could use a do-while, or call it once before
- Note that the first one is **no longer optional**

::

  Call = "call" Identifier+

.. code-block:: cpp

  bool Call()
  {
    if (Accept("call") == false)
      return false;
    
    Expect(Identifier(), "Call requires at least one argument");
    
    while (Identifier());
    
    return true;
  }

- Lets take a look at a more realistic and "complicated" example:

::

  Call = "call" (Identifier ("," Identifier)*)?

- Call may accept no arguments, one argument, or a comma delimited list of arguments
- This is really the only way to implement this logic

.. code-block:: cpp

  bool Call()
  {
    if (Accept("call") == false)
      return false;
    
    // We know that we can only have the comma
    // delimited list if we have at least one argument
    if (Identifier())
    {
      // Every successive comma is optional due to the Kleene star, we must use accept
      // After the comma, the Identifier is definitely expected (there are no other options)
      while (Accept(",") && Expect(Identifier()));
    }
    
    // Note that the above 'if' still did not affect our return value
    // (unless it threw an exception on the Expect call)
    return true;
  }

Recommended reading:

  - Section 2.4 of *Compilers: Principles, Techniques, and Tools* describes grammars in more detail
  - Section 4.3 of *Compilers: Principles, Techniques, and Tools* describes elimination of ambiguity, left recursion, and left factoring