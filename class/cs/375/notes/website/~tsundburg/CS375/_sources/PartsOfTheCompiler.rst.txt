Parts Of The Compiler
=====================
- Compilers can be very cleanly separated into different modular parts
- *Lexical Analysis* - Pick out words, numbers, symbols, and eliminate white space/comments (Tokenizer)
- *Syntax Analysis* - Gives meaning to the ordering of certain tokens, akin to sentence structure (Parser)
- *Abstract Syntax Tree* - A more easily traversable way of describing an input program as opposed to text (AST)
- *Semantic Analysis* - Verifies that the tree is correct by type checking, preventing duplicate members, etc
- *Interpreter* - Walks over the tree to *run* the code typically from leaf to root order
- *Intermediate Code* - A fake assembly that is easily optimized and generated from the AST after Semantic Analysis (IR)
- *Optimization* - Slimming down and replacing parts of the intermediate code with parts that ideally would run faster
- *Code Generation* - Generating the actual assembly for the target platform (x86, ARM, etc)

Lexical Analysis (Tokenizer)
----------------------------
- Breaking strings into words comes from what we do in written language

::

    The boy has 5 goats.

======  ===========
Token   Type
======  ===========
The     Word
boy     Word
has     Word
5       Number
goats   Word
.       Period
======  ===========

- This list of tokens is called a *token stream* and is what we feed to the next phase of *Syntax Analysis*
- The *type* of the token generally ends up being a large enumeration of possible tokens in your language
- We created a convention of separating words by whitespace
- Punctuation is not so convenient and may not have surrounding whitespace

::

  The boy has 5 goats (3 of them are dead)...

======  =================
Token   Type
======  =================
The     Word
boy     Word
has     Word
5       Number
goats   Word
(       OpenParentheses
3       Number
of      Word
them    Word
are     Word
dead    Word
)       CloseParentheses
...     Ellipsis
======  =================

- ``)...`` is not a single token
- We know that ``)`` is a complete token and ``...`` is a complete token
- Whilst ``.`` would be a valid ``Period`` token, we read out as far as possible (**greedy**)
- In languages like C, we can see how this could be much more of a problem

::

  array[0]<=-b
  
Or more conveniently
::

  array[0] <= -b

- A naive tokenizer would treat ``]<=-`` as one token

======  =====================
Token   Type
======  =====================
array   Identifier
[       OpenBracket
0       IntegerLiteral
]       CloseBracket
<=      LessThanOrEqualTo
\-      Minus
b       Identifier
======  =====================

- We read the identifier ``array`` first and stopped at ``[`` because it was not part of an identifier, and so on
- Later, we read ``<`` which is a valid token, however we greedily kept reading and found that ``<=`` is also a valid token
- ``<=-`` is not a valid token, so we backup and accept ``<=`` as our token
- The tokenizer cannot distinguish ``-`` as being *Unary Negation* vs *Binary Subtraction*, this is the parser's job

Syntax Analysis (Parser)
------------------------
- Think of this as proper grammar of a written language (preferably unambiguous)
- Does **NOT** involve type checking (that comes during *Semantic Analysis*)
- Given a stream or array of tokens, we can recognize some sort of order and structure
- We need a formal way of defining our structure, actually called a *grammar*
- There are many different formats for grammars, a nice one is Extended Backus-Naur Form

::

  Statement       = Expression ";" | IfStatement
  IfStatement     = "if" "(" Expression ")" "{" Statement "}"
  Expression      = Identifier BinaryOperator Identifier
  BinaryOperator  = "<" | "<=" | ">" | ">=" | "=" | "=="


By our grammar, the following would be valid:

::

  if (a < b)
  {
    a = b;
  }

What about this?

::

  if (a)
  {
    a = b;
  }

Or this?

::

  if (b = b)
  {
    if (b > b)
    {
      b < b;
    }
  }

Abstract Syntax Tree (AST)
--------------------------
Here is an example AST for the above if statement structure:

.. graphviz::

  digraph
  {
    graph [ordering="out"];
    node [shape=rectangle, fontsize=10, height=0, fontname=Verdana];
    edge [fontsize=7, fontname=Verdana];
    f0 [label="[If]"];
    f1 [label="[If]"];
    b0 [label="[BinaryExpression]\nb = b"];
    b1 [label="[BinaryExpression]\nb > b"];
    b2 [label="[BinaryExpression]\nb < b"];
    
    f0 -> b0 [label="condition"];
    f0 -> f1 [label="statement"];
    f1 -> b1 [label="condition"];
    f1 -> b2 [label="statement"];
  }

The if node might look something like the following:

.. code-block:: cpp

  class IfNode : public StatementNode
  {
    ExpressionNode* mCondition;
    StatementNode* mStatement;
  };

A slightly more expressive version that expands binary operators might look like:

.. graphviz::

  digraph
  {
    graph [ordering="out"];
    node [shape=rectangle, fontsize=10, height=0, fontname=Verdana];
    edge [fontsize=7, fontname=Verdana];
    f0 [label="[If]"];
    f1 [label="[If]"];
    b0 [label="[BinaryExpression]\n="];
    b1 [label="[BinaryExpression]\n>"];
    b2 [label="[BinaryExpression]\n<"];
    b0l [label="[VariableName]\nb"];
    b0r [label="[VariableName]\nb"];
    b1l [label="[VariableName]\nb"];
    b1r [label="[VariableName]\nb"];
    b2l [label="[VariableName]\nb"];
    b2r [label="[VariableName]\nb"];
    
    f0 -> b0 [label="condition"];
    f0 -> f1 [label="statement"];
    f1 -> b1 [label="condition"];
    f1 -> b2 [label="statement"];
    
    b0 -> b0l;
    b0 -> b0r;
    b1 -> b1l;
    b1 -> b1r;
    b2 -> b2l;
    b2 -> b2r;
  }

Another more complicated example:

::

  namespace Farm
  {
    class Animal
    {
      function Speak();
    }
    
    class Tool
    {
      var Name : String;
      var MaxUses : Integer;
      
      function Use();
    }
  }

Might look something like this in AST form:

.. graphviz::

  digraph
  {
    graph [ordering="out"];
    node [shape=rectangle, fontsize=10, height=0, fontname=Verdana];
    "[Namespace]\nFarm" -> "[Class]\nAnimal";
    "[Namespace]\nFarm" -> "[Class]\nTool";
    "[Class]\nAnimal" -> "[Function]\nSpeak";
    "[Class]\nTool" -> "[Variable]\nName";
    "[Variable]\nName" -> "[Type]\nString";
    "[Class]\nTool" -> "[Variable]\nMaxUses";
    "[Variable]\nMaxUses" -> "[Type]\nInteger";
    "[Class]\nTool" -> "[Function]\nUse";
  }

The variable node in code could look like:

.. code-block:: cpp

  class VariableNode : public AbstractNode
  {
    Token mName;
    TypeNode* mType;
  };

- A tree is a very expressive data structure
- Can describe ordered elements such as a list of statements, parameters, members, etc
- Can describe nested elements such as scopes, functions, types, etc
- Each node type can hold whatever data is needed
- Expression trees are a subset of the AST

::

  6 + 2 * 4

.. graphviz::

  digraph
  {
    node [shape=rectangle, fontsize=10, height=0, fontname=Verdana];
    "+" -> "6";
    "+" -> "*";
    "*" -> "2";
    "*" -> "4";
  }

::

  a = 5 + 9 * b + c / 6 * (5 + 5)

.. graphviz::

  digraph
  {
    node [shape=rectangle, fontsize=10, height=0, fontname=Verdana];
    t00 [label="a"];
    t01 [label="="];
    t02 [label="5"];
    t03 [label="+"];
    t04 [label="9"];
    t05 [label="*"];
    t06 [label="b"];
    t07 [label="+"];
    t08 [label="c"];
    t09 [label="/"];
    t10 [label="6"];
    t11 [label="*"];
    t12 [label="5"];
    t13 [label="+"];
    t14 [label="5"];
    
    t01 -> t00;
    t01 -> t07;
    t07 -> t03;
    t03 -> t02;
    t03 -> t05;
    t05 -> t04;
    t05 -> t06;
    t07 -> t11;
    t11 -> t09;
    t09 -> t08;
    t09 -> t10;
    t11 -> t13;
    t13 -> t12;
    t13 -> t14;
  }

Semantic Analysis
-----------------
- Verifies that a program is type safe
- Reporting errors for duplicate members, ambiguous overloads, non-existent operators between types, etc
- Determines implicit conversions, overload resolution, scoped variable resolution, proper continue/break statements, etc

For example, given the expression:

::

  1) float a;
  2) a = 5;

- Responsible for understanding what ``a`` is on line 2
- Looks up ``a`` in the *symbol table* and resolves that ``a`` is a float

Line 2 may have the following AST:

.. graphviz::

  digraph
  {
    node [shape=rectangle, fontsize=10, height=0, fontname=Verdana];
    "[BinaryOperator]\n=" -> "[VariableName]\n'a' of type 'float'"
    "[BinaryOperator]\n=" -> "[Literal]\n'5' of type 'int'"
  }

- Determines that the binary operator is between two types that are not the same
- May first attempt to look for an overloaded/builtin assignment operator between float/int
- May also look for an implicit conversion from int to float (right to left side)
- An implicit conversion can be inserted into the AST for future passes

.. graphviz::

  digraph
  {
    node [shape=rectangle, fontsize=10, height=0, fontname=Verdana];
    "[BinaryOperator]\n=" -> "[VariableName]\n'a' of type 'float'"
    "[BinaryOperator]\n=" -> "[TypeCast]\nfloat"
    "[TypeCast]\nfloat" -> "[Literal]\n'5' of type 'int'"
  }

- Could also report an error ``No conversion exists from type 'int' to type 'float'``

Interpreter
-----------
- Many different definitions of what an *interpreter* is
- Generally means running the code without compiling to assembly
- *AST Interpreter*: running the code by walking the AST
- Typically slower and recursive, which blows the stack easily
- Easiest first step to get a language running
- Can be changed over to a virtual byte code or actual assembly afterwards

::

  4 * 10 + 3 - 1

.. graphviz::

  digraph
  {
    node [shape=rectangle, fontsize=10, height=0, fontname=Verdana];
    "-" -> "+";
    "-" -> "1";
    "+" -> "*";
    "+" -> "3";
    "*" -> "4";
    "*" -> "10";
  }

- Start from the root node (``-`` in this case)
- **Binary** nodes walk the left first, then the right, then evaluate the operator
- **Numbers** and literals result in their own value
- Interpreter requires space for local variable storage (stack)
- Also requires space for globals
